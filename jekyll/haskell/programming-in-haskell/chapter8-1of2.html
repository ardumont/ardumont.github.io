<p>
Before being able to fool around on this chapter, here are some pre-requisites:
</p>

<div class="org-src-container">

<pre class="src src-haskell">import Control.Monad
import Data.Char(isDigit, isUpper, isLower, isAlpha, isAlphaNum, isSpace)

newtype Parser a  =  P (String -&gt; [(a,String)])

parse             :: Parser a -&gt; String -&gt; [(a,String)]
parse (P p) inp   =  p inp

instance Monad Parser where
  -- return parser: always succeeds by returning the result value
  -- v without consuming the input
    return v      =  P (\inp -&gt; [(v,inp)])

  -- bind
    p &gt;&gt;= f       =  P (\inp -&gt; case parse p inp of
		       []        -&gt; []
		       [(v,out)] -&gt; parse (f v) out)

instance MonadPlus Parser where
  -- fail
    mzero         =  P (\_ -&gt; [])
  -- choice
    p `mplus` q   =  P (\inp -&gt; case parse p inp of
		       []        -&gt; parse q inp
		       [(v,out)] -&gt; [(v,out)])
</pre>
</div>
<p>
I will not enter into much detail here because <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Monad">monads</a> will be presented later.
</p>

<p>
As always, you'll find the <a href="https://github.com/ardumont/haskell-lab/blob/master/src/Parsers.hs">sources on github</a>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">int :: Parser Int</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
The library file also defines a parser <code>int :: Parser Int</code> for an integer. Without looking at this definition, define int.
</p>

<p>
<span class="underline">Hint:</span> an integer is either a minus symbol followed by a natural number, or a natural number.
</p>
</blockquote>

<p>
The functions I will use to solve the problem:
</p>
<div class="org-src-container">

<pre class="src src-haskell">many :: Parser a -&gt; Parser [a]
many p = many1 p +++ return []

many1 :: Parser a -&gt; Parser [a]
many1 p = do v  &lt;- p
	     vs &lt;- many p
	     return (v:vs)

sat :: (Char -&gt; Bool) -&gt; Parser Char
sat p = do x &lt;- item; if p x then return x else Parsers.fail

nat :: Parser Int
nat = do xs &lt;- many1 digit
	 return (read xs)

space :: Parser ()
space = do many (sat isSpace)
	   return ()

token :: Parser a -&gt; Parser a
token p = do space
	     x &lt;- p
	     space
	     return x

natural :: Parser Int
natural = token nat

string :: String -&gt; Parser String
string [] = return []
string (x:xs) = do char x
		   string xs
		   return (x:xs)

symbol :: String -&gt; Parser String
symbol s = token (string s)
</pre>
</div>

<p>
I have a 'choice' between parsing a negative natural number (beginning with '-') or a positive natural number.
</p>
<div class="org-src-container">

<pre class="src src-haskell">int :: Parser Int
int = do symbol "-"
	 n &lt;- natural
	 return (-n)
	 +++ natural
</pre>
</div>

<p>
Examples:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Parsers&gt; parse int "-1"
[(-1,"")]
*Parsers&gt; parse int "-10"
[(-10,"")]
*Parsers&gt; parse int "-101"
[(-101,"")]
*Parsers&gt; parse int "101"
[(101,"")]
*Parsers&gt; parse int " - 101"
[(-101,"")]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">comment :: Parser ()</h2>
<div class="outline-text-2" id="text-2">
<blockquote>
<p>
Define a parser <code>comment :: Parser ()</code> for ordinary Haskell comments that begin with the symbol &#x2013; and extend to the end of the current line, which is represented by the control character ’\n’.
</p>
</blockquote>

<p>
Here are the functions I will use to answer the question:
</p>
<div class="org-src-container">

<pre class="src src-haskell">char :: Char -&gt; Parser Char
char x = sat (== x)

alphanum :: Parser Char
alphanum = sat isAlphaNum
</pre>
</div>

<p>
Here is a first naive approach where you specify the characters you can read:
</p>
<div class="org-src-container">

<pre class="src src-haskell">comment :: Parser ()
comment = do symbol "--"
	     many (alphanum +++ char ' ')
	     char '\n'
	     return ()
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">*Parsers&gt; parse comment "--ignoredcomment\nnotignored"
[((),"notignored")]
*Parsers&gt; parse comment "--ignored   comment till\nnotignored"
[((),"notignored")]
*Parsers&gt; parse comment "--42 ignoredcomment till\nnotignored"
[((),"notignored")]
</pre>
</div>

<p>
Indeed, for some edge cases, this won't work:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Parsers&gt; parse comment "-- comment!@# that breaks\nnotignored"
[]
</pre>
</div>

<p>
A simpler and better approach would be to parse anything that's not the ending control char '\n':
</p>

<div class="org-src-container">

<pre class="src src-haskell">comment :: Parser ()
comment = do symbol "--"
	     many (sat (/= '\n'))
	     char '\n'
	     return ()
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">*Parsers&gt; parse comment "--comment!@# doesnotbreak\nnotignored"
[((),"notignored")]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Draw Tree 1/2</h2>
<div class="outline-text-2" id="text-3">
<blockquote>
<p>
Using our second grammar for arithmetic expressions, draw the two possible parse trees for the expression <code>2 + 3 + 4</code>.
</p>
</blockquote>

<p>
The grammar:
</p>
<div class="org-src-container">

<pre class="src src-txt">expr   ::= expr + expr | term
term   ::= term * term | factor
factor ::= (expr) | nat
nat    ::= 0 | 1 | ... |
</pre>
</div>

<p>
<code>2+3+4</code> can be read in 2 ways:
</p>
<ul class="org-ul">
<li><code>(2+3)+4</code>
</li>
</ul>


<div class="figure">
<p><img src="./resources/ch8-ex3-1.png" alt="ch8-ex3-1.png" />
</p>
</div>

<ul class="org-ul">
<li><code>2+(3+4)</code>
</li>
</ul>


<div class="figure">
<p><img src="./resources/ch8-ex3-2.png" alt="ch8-ex3-2.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Draw Tree 2/2</h2>
<div class="outline-text-2" id="text-4">
<blockquote>
<p>
Using our third grammar for arithmetic expressions, draw the parse trees for the expressions <code>2 + 3</code>, <code>2 ∗ 3 ∗ 4</code> and <code>(2 + 3) + 4</code>.
</p>
</blockquote>

<p>
The grammar:
</p>
<div class="org-src-container">

<pre class="src src-txt">expr   ::= term (+ expr | epsilon)
term   ::= factor (* term | epsilon)
factor ::= (expr) | nat
nat    ::= 0 | 1 | ... |
</pre>
</div>

<ul class="org-ul">
<li><code>2+3</code>
</li>
</ul>


<div class="figure">
<p><img src="./resources/ch8-ex4-1.png" alt="ch8-ex4-1.png" />
</p>
</div>

<ul class="org-ul">
<li><code>2*3*4</code>
</li>
</ul>


<div class="figure">
<p><img src="./resources/ch8-ex4-2.png" alt="ch8-ex4-2.png" />
</p>
</div>

<ul class="org-ul">
<li><code>(2+3)*4</code>
</li>
</ul>


<div class="figure">
<p><img src="./resources/ch8-ex4-3.png" alt="ch8-ex4-3.png" />
</p>
</div>

<p>
#+./resources/ch8-ex3-1.png <img src="http://adumont.fr/blog/wp-content/uploads/2013/04/wpid-ch8-ex3-1.png" alt="wpid-ch8-ex3-1.png" />
#+./resources/ch8-ex3-2.png <img src="http://adumont.fr/blog/wp-content/uploads/2013/04/wpid-ch8-ex3-2.png" alt="wpid-ch8-ex3-2.png" />
</p>

<p>
#+./resources/ch8-ex4-1.png <img src="http://adumont.fr/blog/wp-content/uploads/2013/04/wpid-ch8-ex4-1.png" alt="wpid-ch8-ex4-1.png" />
#+./resources/ch8-ex4-2.png <img src="http://adumont.fr/blog/wp-content/uploads/2013/04/wpid-ch8-ex4-2.png" alt="wpid-ch8-ex4-2.png" />
#+./resources/ch8-ex4-3.png <img src="http://adumont.fr/blog/wp-content/uploads/2013/04/wpid-ch8-ex4-3.png" alt="wpid-ch8-ex4-3.png" />
</p>
</div>
</div>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Strict evaluation</a></li>
<li><a href="#sec-2">power</a></li>
<li><a href="#sec-3">steps</a></li>
<li><a href="#sec-4">tail-recursion</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Strict evaluation</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
Considering the function call <code>f a b</code>, how would you force the strict evaluation of <code>a only</code>, <code>b only</code>, and <code>both a and b</code>?
</p>
</blockquote>

<ul class="org-ul">
<li>a only
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell">f !a b
</pre>
</div>

<ul class="org-ul">
<li>b only
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell">f a !b
</pre>
</div>

<ul class="org-ul">
<li>a and b
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell">f !a !b
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">power</h2>
<div class="outline-text-2" id="text-2">
<blockquote>
<p>
Computing the power of a number x can be achieved using the following function:
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-haskell">power :: (Integral a1, Num a) =&gt; a -&gt; a1 -&gt; a
power x k = if k == 0
	    then 1
	    else if (k `mod` 2) == 0
		 then power (x*x) (k `div` 2)
		 else x * power (x*x) (k `div` 2)
</pre>
</div>
<blockquote>
<p>
Perform a simple time and space efficiency analysis of the function.
</p>
</blockquote>

<p>
First a rewriting which does not impact the analysis asked for.
</p>
<div class="org-src-container">

<pre class="src src-haskell">power' :: (Integral a1, Num a) =&gt; a -&gt; a1 -&gt; a
power' _ 0 = 1
power' x k
  | (k `mod` 2) == 0 = power' (x*x) (k `div` 2)
  | otherwise        = x * power' (x*x) (k `div` 2)
</pre>
</div>

<p>
Example of strict resolution:
</p>
<ul class="org-ul">
<li>2<sup>3</sup>:
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell">power 2 3 = 2 * power' (2*2) (3 `div` 2)     -- 3 `mod` 2 /= 0
	  = 2 * power' 4 1
	  = 2 * 4 * power' (4*4) (1 `div` 2)
	  = 2 * 4 * power' 16 0
	  = 2 * 4 * 1                        -- by definition
	  = 8
</pre>
</div>

<ul class="org-ul">
<li>10<sup>2</sup>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell">power 10 2 = power' (10*10) (2 `div` 2)         -- 2 `mod` 2 == 0
	   = power' 100 1
	   = 100 * power' (100*100) (1 `div` 2)
	   = 100 * power' 10000 0
	   = 100 * 1                            -- by definition
	   = 100
</pre>
</div>

<ul class="org-ul">
<li>time efficiency analysis
</li>
</ul>

<p>
Step counting analysis:
</p>

<div class="org-src-container">

<pre class="src src-haskell">Tpower _ 0 = 1
Tpower x k
  | (k `mod` 2) == 0 = 1 + T_x*x + T_kdiv2 + T_power(x*x) (k `div` 2)                         = 1 + 1 + 1 + Tpower
  | otherwise        = T_x*x + T_kdiv2 + T_power(x*x) (k `div` 2) + Tx*power(x*x) (k `div` 2) = 1 + 1 + 1 + Tpower
</pre>
</div>

<p>
O(k), with k the exponent
</p>

<ul class="org-ul">
<li>space efficiency analysis
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">steps</h2>
<div class="outline-text-2" id="text-3">
<blockquote>
<p>
Assume a list of length n in which every item requires O(m) steps to be computed.
Suppose that the functions <code>length</code>, <code>head</code> and <code>sum</code> need to be applied to this list.
How many steps would they take (in asymptotic terms) in each of the following cases:
</p>

<p>
a) a lazy list,
</p>

<p>
b) a list in which all tails are strictly evaluated.
</p>

<p>
c) a list in which all heads and all tails are strictly evaluated.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">tail-recursion</h2>
<div class="outline-text-2" id="text-4">
<blockquote>
<p>
Consider the following program:
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-haskell">prodsum :: (Eq a, Num a) =&gt; a -&gt; a
prodsum x = prod x + sum x

prod :: (Eq a, Num a) =&gt; a -&gt; a
prod 0 = 1
prod n = n * prod (n-1)

sum :: (Eq a, Num a) =&gt; a -&gt; a
sum 0 = 0
sum n = n + sum (n-1)
</pre>
</div>
<blockquote>
<p>
a) Change the definition of <code>sum</code> and <code>prod</code> into tail-recursive ones.
</p>

<p>
b) Using the Burstall-Darlington transformation system, write a new definition of <code>prodsum</code> (using tuples) such that the result is computed in one pass.
</p>

<p>
c) Change this definition into one that avoids using tuples and which is tail-recursive.
</p>
</blockquote>
</div>
</div>

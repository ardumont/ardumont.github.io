
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Monoid</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>`mempty` is the identity function
</li>

<li>`mappend` is the binary function
</li>

<li>haskell class definition:
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell">import Data.Monoid

class Monoid m where
    mempty :: m
    mappend :: m -&gt; m -&gt; m
    mconcat :: [m] -&gt; m
    mconcat = foldr mappend mempty
</pre>
</div>

<ul class="org-ul">
<li>Monoid obeys Laws (not enforced by haskell)
<ul class="org-ul">
<li>mempty `mappend` x = x
</li>
<li>x `mappend` mempty = x
</li>
<li>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
</li>
</ul>
</li>

<li>Example of monoid instances:
<ul class="org-ul">
<li>List
<div class="org-src-container">

<pre class="src src-haskell">instance Monoid [a] where
    mempty = []
    mappend = (++)
</pre>
</div>
</li>
</ul>
</li>

<li>Product

<div class="org-src-container">

<pre class="src src-haskell">instance Num a =&gt; Monoid (Product a) where
    mempty = Product 1
    Product x `mappend` Product y = Product (x * y)
</pre>
</div>
</li>

<li>Sum
<div class="org-src-container">

<pre class="src src-haskell">instance Num a =&gt; Monoid (Sum a) where
    mempty = Sum 0
    Sum x `mappend` Sum y = Sum (x + y)
</pre>
</div>
</li>

<li>Any
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell">instance Monoid Any where
    mempty = Any False
    Any x `mappend` Any y = Any (x || y)
</pre>
</div>

<ul class="org-ul">
<li>All
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell">instance Monoid All where
    mempty = All True
    All x `mappend` All y = A (x &amp;&amp; y)
</pre>
</div>
</div>
</div>

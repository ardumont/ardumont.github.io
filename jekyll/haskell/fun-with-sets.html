<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">sets</a>
<ul>
<li><a href="#sec-1-1">Type</a></li>
<li><a href="#sec-1-2">NewEmpty</a></li>
<li><a href="#sec-1-3">Add</a></li>
<li><a href="#sec-1-4">Contains</a></li>
<li><a href="#sec-1-5">Singleton</a></li>
<li><a href="#sec-1-6">Union</a></li>
<li><a href="#sec-1-7">Intersect</a></li>
<li><a href="#sec-1-8">Difference</a></li>
<li><a href="#sec-1-9">Filter</a></li>
<li><a href="#sec-1-10">Remove</a></li>
<li><a href="#sec-1-11">set creation</a></li>
<li><a href="#sec-1-12">Exists</a></li>
<li><a href="#sec-1-13">Map</a></li>
<li><a href="#sec-1-14">All</a></li>
</ul>
</li>
<li><a href="#sec-2">sources</a></li>
</ul>
</div>
</div>
<p>
So, the idea is to implement a bunch of functions relative to the mathematical notion of Set.
But, the Set must be implemented as a function.
</p>

<p>
<span class="underline">Note:</span>
To avoid repetition, I will associate some examples computed from the REPL into haskell block of code directly after the function definition.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">sets</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Type</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The set has to be defined using a specific type, it must be a function.
</p>

<div class="org-src-container">

<pre class="src src-haskell">type Set a = a -&gt; Bool
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">NewEmpty</h3>
<div class="outline-text-3" id="text-1-2">
<p>
We'll begin by implementing a simple function called newEmpty which return a function that always return False:
</p>
<div class="org-src-container">

<pre class="src src-haskell">newEmpty :: Set a
newEmpty = \_ -&gt; False

*FunSet&gt; newEmpty []
False
*FunSet&gt; newEmpty 1
False
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Add</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Given an already existing set and a new entry, return a new set.
</p>
<div class="org-src-container">

<pre class="src src-haskell">add :: Eq a =&gt; Set a -&gt; a -&gt; Set a
add s e = \i -&gt; (e == i) || contains s i

*FunSet&gt; ((add newEmpty 1) 1)
True
*FunSet&gt; ((add newEmpty 1) 2)
False
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Contains</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Is this parameter in the set?
</p>

<div class="org-src-container">

<pre class="src src-haskell">contains :: Set a -&gt; a -&gt; Bool
contains s e = s e

*FunSet&gt; contains newEmpty 1
False
*FunSet&gt; contains (add newEmpty 1) 1
True
*FunSet&gt; contains (add newEmpty 1) 2
False
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Singleton</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Another simple set creation given an entry.
</p>
<div class="org-src-container">

<pre class="src src-haskell">singleton :: Eq a =&gt; a -&gt; Set a
singleton a = \e -&gt; (a == e)

*FunSet&gt; contains (singleton 1) 1
True
*FunSet&gt; contains (singleton 1) 3
False
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Union</h3>
<div class="outline-text-3" id="text-1-6">
<p>
The standard union set definition - all which is a or b (or both).
</p>

<div class="org-src-container">

<pre class="src src-haskell">union :: Set a -&gt; Set a -&gt; Set a
union a b = \e -&gt; a e || b e

*FunSet&gt; (union (singleton 1) (singleton 2)) 1
True
*FunSet&gt; (union (singleton 1) (singleton 2)) 2
True
*FunSet&gt; (union (singleton 1) (singleton 2)) 3
False
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Intersect</h3>
<div class="outline-text-3" id="text-1-7">
<p>
The standard intersection definition - all which is in a and b.
</p>

<div class="org-src-container">

<pre class="src src-haskell">intersect :: Set a -&gt; Set a -&gt; Set a
intersect a b = \e -&gt; a e &amp;&amp; b e

*FunSet&gt; (intersect (union (singleton 1) (singleton 2)) (singleton 1)) 2
False
*FunSet&gt; (intersect (union (singleton 1) (singleton 2)) (singleton 1)) 1
True
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">Difference</h3>
<div class="outline-text-3" id="text-1-8">
<p>
The standard difference definition set - all which is in a but not in b.
</p>
<div class="org-src-container">

<pre class="src src-haskell">diff :: Set a -&gt; Set a -&gt; Set a
diff a b = \e -&gt; a e &amp;&amp; not (b e)

*FunSet&gt; (diff (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3))) 1
False
*FunSet&gt; (diff (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3))) 2
True
*FunSet&gt; (diff (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3))) 3
False
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">Filter</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Given a predicate and a set, return a set that satisfies both the predicate and the existing set.
This reminds me of something&#x2026; Indeed, if we see the predicate as a set, the filter is then simply the intersect function.
</p>

<div class="org-src-container">

<pre class="src src-haskell">filter' :: (a -&gt; Bool) -&gt; Set a -&gt; Set a
filter' = intersect

*FunSet&gt; (filter' (== 2) (union (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3)))) 3
False
*FunSet&gt; (filter' (== 3) (union (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3)))) 3
True
*FunSet&gt; (filter' (&gt;= 1) (union (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3)))) 3
True
*FunSet&gt; (filter' (&gt;= 1) (union (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3)))) 1
True
*FunSet&gt; (filter' (&gt;= 1) (union (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3)))) 2
True
*FunSet&gt; (filter' (&gt;= 1) (union (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3)))) 10
False
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">Remove</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Given an entry and a set, remove the entry from the set.
</p>

<div class="org-src-container">

<pre class="src src-haskell">remove :: Eq a =&gt; a -&gt; Set a -&gt; Set a
remove e s = \i -&gt; (diff s (singleton e)) i

*FunSet&gt; (remove 1 (union (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3)))) 1
False
*FunSet&gt; (remove 1 (union (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3)))) 2
True
*FunSet&gt; (remove 1 (union (union (singleton 1) (singleton 2)) (union (singleton 1) (singleton 3)))) 3
True
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">set creation</h3>
<div class="outline-text-3" id="text-1-11">
<p>
At this level, I was fed up to type so much to make a set, so I created a utility function to create set from a list.
</p>

<div class="org-src-container">

<pre class="src src-haskell">set :: Eq a =&gt; [a] -&gt; Set a
set [] = newEmpty
set (x:xs) = add (set xs) x

*FunSet&gt; map (set [1,2,3]) [0..4]
[False,True,True,True,False]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">Exists</h3>
<div class="outline-text-3" id="text-1-12">
<p>
Is there any element in Set that satisfies the predicate?
</p>
<div class="org-src-container">

<pre class="src src-haskell">exists' :: (Enum a, Num a, Ord a) =&gt; Set a -&gt; (a -&gt; Bool) -&gt; Bool
exists' s p = or $ map ( \x -&gt; contains s x &amp;&amp; p x ) [-1000..1000]

*FunSet&gt; exists' (set [1..3]) (== 1)
True
*FunSet&gt; exists' (set [1..3]) (== 0)
False
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">Map</h3>
<div class="outline-text-3" id="text-1-13">
<p>
Given a function and a set, return a new set.
</p>

<div class="org-src-container">

<pre class="src src-haskell">map' :: (Enum a, Num a, Ord a, Eq a, Eq b) =&gt; (a -&gt; b) -&gt; Set a -&gt; Set b
map' f s = \y -&gt; exists' s (\x -&gt; f x == y)

*FunSet&gt; map (set [1,2,3]) [0..4]
[False,True,True,True,False]
*FunSet&gt; map (map' (+1) (set [1,2,3])) [0..4]
[False,False,True,True,True]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14">All</h3>
<div class="outline-text-3" id="text-1-14">
<p>
Checks if the content of all the set satisfy the predicate.
</p>
<div class="org-src-container">

<pre class="src src-haskell">all' :: (Enum a, Num a, Ord a) =&gt; Set a -&gt; (a -&gt; Bool)-&gt; Bool
all' s p = and $ map p (filter s [-1000..1000])

*FunSet&gt; all' (set [1..3]) (&lt;= 4)
True
*FunSet&gt; all' (set [1..3]) (&lt;= 3)
True
*FunSet&gt; all' (set [1..3]) (&lt;= 2)
False
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">sources</h2>
<div class="outline-text-2" id="text-2">
<p>
<a href="https://github.com/ardumont/my-haskell-lab/blob/master/src/FunSet.hs">FunSet.hs</a>
</p>
</div>
</div>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">first implementation</a></li>
<li><a href="#sec-2">Second Implementation</a></li>
<li><a href="#sec-3">Last</a></li>
</ul>
</div>
</div>
<blockquote>
<p>
Given two sequences x and y, calculate the Levenshtein distance of x and y, i. e. the minimum number of edits needed to transform x into y. The allowed edits are:
</p>

<ul class="org-ul">
<li>insert a single item
</li>
<li>delete a single item
</li>
<li>replace a single item with another item
</li>
</ul>
</blockquote>

<p>
I did 3 implementations for this one.
They all passed the tests but only the last one did pass without timeout on <a href="http://www.4clojure.com/">4clojure.com</a>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">first implementation</h2>
<div class="outline-text-2" id="text-1">
<p>
I liked this one. I reversed the input and use the destructuring of clojure with the head and tail of the list.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn lv
    [a b]
    (letfn
	[(L [[f &amp; r :as x] [h &amp; t :as y]]
	   (let [l (count x)
		 m (count y)]
	     (cond (= 0 l) m
		   (= 0 m) l
		   (= f h) (L r t)
		   :else (+ 1 (min (L x t)
				   (L r y)
				   (L r t))))))]
      (L (-&gt; a vec rseq) (-&gt; b vec rseq))))
</pre>
</div>

<p>
Unfortunately this timeout.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Second Implementation</h2>
<div class="outline-text-2" id="text-2">
<p>
I <a href="http://clojure.org/data_structures">initially</a> thought of the timeout of the previous implementation because of the count call.
So I tried to act on this but failure, tests ok, timeout on <a href="http://www.4clojure.com/">4clojure.com</a>.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn lv
    [a b]
    (letfn
	[(L [[f &amp; r :as x] l [h &amp; t :as y] m]
	   (let [l- (- l 1)
		 m- (- m 1)]
	     (cond (= 0 l) m
		   (= 0 m) l
		   (= f h) (L r l- t m-)
		   :else (+ 1 (min (L x l t m-)
				   (L r l- y m)
				   (L r l- t m-))))))]
      (L (-&gt; a reverse vec) (count a) (-&gt; b reverse vec) (count b))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Last</h2>
<div class="outline-text-2" id="text-3">
<p>
Finally, I worked directly with the string as vector and worked with indexes and length.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn lv
  [a b]
  (let [x (vec a)
	y (vec b)]
    (letfn
	[(L [l m]
	   (let [l- (- l 1)
		 m- (- m 1)]
	     (cond (= 0 l) m
		   (= 0 m) l
		   (= (x l-) (y m-)) (L l- m-)
		   :else (+ 1 (min
				   (L l m-)
				   (L l- m)
				   (L l- m-))))))]
      (L (count x) (count y)))))

(fact
  (lv "kitten" "sitting")               =&gt; 3
  (lv "closure" "clojure")              =&gt; 1
  (lv "clojure" "closure")              =&gt; 1
  (lv "xyx" "xyyyx")                    =&gt; 2
  (lv "" "123456")                      =&gt; 6
  (lv "Clojure" "Clojure")              =&gt; 0
  (lv "" "")                            =&gt; 0
  (lv  [] [] )                          =&gt; 0
  (lv [1 2 3 4] [0 2 3 4 5])            =&gt; 2
  (lv '(:a :b :c :d) '(:a :d))          =&gt; 2
  (lv "ttttattttctg" "tcaaccctaccat")   =&gt; 10
  (lv "gaattctaatctc" "caaacaaaaaattt") =&gt; 9)
</pre>
</div>
<p>
source: <a href="https://github.com/ardumont/my-4clojure-lab/blob/master/src/my_4clojure_lab/149/core101.clj">101</a>
</p>
</div>
</div>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">make-children</a></li>
<li><a href="#sec-2">breadth-first</a></li>
<li><a href="#sec-3">main function</a></li>
</ul>
</div>
</div>
<p>
Here is the problem statement:
</p>

<blockquote>
<p>
Given a pair of numbers, the start and end point, find a path between the two using only three possible operations:
</p>
<ul class="org-ul">
<li>double
</li>
<li>halve (odd numbers cannot be halved)
</li>
<li>add 2
</li>
</ul>
<p>
Find the shortest path through the "maze". Because there are multiple shortest paths, you must return the length of the shortest path, not the path itself.
</p>
</blockquote>

<p>
For this, I did three functions to separate concerns:
</p>
<ul class="org-ul">
<li>make-children function: deals with the operations (/, +, *) for each value, we can have 3 values for even number or 2 values for odd ones.
</li>
<li>lazy breadth-first tree: the construction of each possible values for each step (we use the make-children function)
</li>
<li>the lazy searching function: drop the returned values from the breadth-first tree as long as we do not find at least one possible value.
</li>
</ul>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">make-children</h2>
<div class="outline-text-2" id="text-1">
<p>
This function has only for goal to:
</p>
<ul class="org-ul">
<li>compute the result of the operations on a given value (if the value is odd, we do not consider the / operation)
</li>
<li>compute the new distance (+ 1)
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(defn mkc
  [[s d]]
  (let [[_ &amp; r :as vf] [/ * + ]]
    (map (fn [f] [(f s 2) (+ 1 d)]) (if (even? s) vf r))))
</pre>
</div>

<p>
Some unit tests representing the use cases (even and odd value):
</p>

<div class="org-src-container">

<pre class="src src-clojure">(fact
  (mkc [10 1]) =&gt; [[5 2] [20 2] [12 2]]
  (mkc [9 1])  =&gt; [[18 2]
		   [11 2]])
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">breadth-first</h2>
<div class="outline-text-2" id="text-2">
<p>
For each node in the queue, we compute the children via the make-children function and enqueue them.
We begin the algorithm by adding the initial input into the queue (the current value and an initial distance of 1)
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn bfs
  "breadth-first search lazily"
  ([s]
      ((fn nx [q]
	 (lazy-seq
	  (when (seq q)
	    (let [n (peek q)
		  c (mkc n)]
	      (cons n (nx (into (pop q) c)))))))
       (conj clojure.lang.PersistentQueue/EMPTY [s 1]))))

(fact
  (take 1 (bfs 1)) =&gt; '([1 1])
  (take 4 (bfs 2)) =&gt; '([2 1] [1 2] [4 2] [4 2]))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">main function</h2>
<div class="outline-text-2" id="text-3">
<p>
This is the main algorithm.
</p>

<p>
For the simple case where s(tart) and e(nd) are equals, we return directly 1.
</p>

<p>
Else, as long as we do not find an entry for which the starting and the ending match, we drop them.
</p>

<p>
As soon as we find one input that matches the predicate, we retrieve the distance and return it.
Indeed, as we search in breadth, we hit the minimal distance.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn maze
  [s e]
  (if (= s e) 1 (let [[[_ d]] (drop-while (fn [[s _]] (not= s e)) (bfs s))] d)))

(fact
  (maze 1 1)  =&gt;  1
  (maze 3 12) =&gt;  3
  (maze 12 3) =&gt;  3
  (maze 5 9)  =&gt;  3
  (maze 9 2)  =&gt;  9
  (maze 9 12) =&gt;  5)
</pre>
</div>
<p>
source: <a href="https://github.com/ardumont/my-4clojure-lab/blob/master/src/my_4clojure_lab/149/core106.clj">106</a>
</p>

<p>
<b>note</b>
As this algorithm is lazy and as we drop the head (using drop-while), we could compute forever without smashing the stack :D.
</p>
</div>
</div>

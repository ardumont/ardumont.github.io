<p>
It has been a while since I implemented this and I thought this was time to show it.
</p>

<p>
Plus, I will made a little demo in video to show the result.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Rules</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>live cell with 2 or 3 nb stays live
</li>
<li>live cell with less than 2 dies
</li>
<li>live cell with more than 3 dies
</li>
<li>dead cell with 3 comes to life
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Code</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Game</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Computations</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The usual namespace declaration:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(ns clj-of-life.game "A namespace to compute the game of life policy"
  (:require [clj-of-life.draw :as d]
	    [midje.sweet :as m]));; I like to add my test in the same namespace for documentation in the code
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Extension</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We create a higher-order function <b>stepper</b>, which given a function 'neighbours-fn', return a function computing the new universe given a previous one.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn stepper
  "Compute the new universe (of live cells) from the previous one depending on the neighbours-fn function."
  [neighbours-fn]
  (fn [universe]
    (let [freq (frequencies (mapcat neighbours-fn universe))]
      (set (for [[cell n] freq
		 :when (or (= n 3)
			   (and (= n 2)
				(universe cell)))]
	     cell)))))
</pre>
</div>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Basic implementation</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
For this, we will need to be able to compute the neighbours cell of a cell (represented by [x, y] coordinates).
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn neighbours "Compute the neighbours of a cell"
  [[x y]]
  (for [dx [-1 0 1] dy [-1 0 1] :when (not= dx dy 0)]
    [(+ x dx) (+ y dy)]))

(m/fact :simple-check-around-neighbours
  (neighbours [0 0]) =&gt; (contains [-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1] :in-any-order)
  (neighbours [3 1]) =&gt; (contains [2 0] [2 1] [2 2] [3 0] [3 2] [4 0] [4 1] [4 2] :in-any-order))
</pre>
</div>

<p>
With the <b>stepper</b> function, we can now have a basic game of life implementation using the <b>neighbours</b> function:
</p>

<div class="org-src-container">

<pre class="src src-clojure">;; one simple game of life implem
(def next-state-universe (stepper neighbours))

(m/fact
  (next-state-universe #{[0 1]})  =&gt; #{}
  (next-state-universe #{[0 1] [0 2]}) =&gt; #{}
  (next-state-universe #{[0 1] [0 2] [1 1]}) =&gt; #{[0 1] [0 2] [1 1] [1 2]})
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Bootstrap</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
We need to be able to bootstrap a <b>universe</b> (random cells smashed together):
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn random-universe "Generate a random universe of live cells"
  [size]
  (let [n (rand-int (/ (* size size) 2))]
    (set (repeatedly n (fn [] [(rand-int size) (rand-int size)])))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Source</h3>
<div class="outline-text-3" id="text-2-4">
<p>
<a href="https://github.com/ardumont/clj-of-life/blob/master/src/clj_of_life/game.clj">game.clj</a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Draw</h3>
<div class="outline-text-3" id="text-2-5">
</div><div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Graphical</h3>
<div class="outline-text-3" id="text-2-6">
<p>
We'll use clojure's capacity of java interoperability to do some graphical visualisation.
</p>

<p>
Here is the <b>draw.clj</b> namespace:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(def *size-cell 10);; size of the cell
(def *offset 29)   ;; for the border drawn in gnome (do not work under stumpwm)
</pre>
</div>

<p>
Some drawing utility functions:
</p>
<div class="org-src-container">

<pre class="src src-clojure">(defn- get-gfx "Given a width and a height, returns a frame with these dimension"
  [width height]
  (.getGraphics
   (doto (javax.swing.JFrame.)
     (.setDefaultCloseOperation javax.swing.WindowConstants/DISPOSE_ON_CLOSE)
     (.setSize width height)
     (.setVisible true))))

(defn get-drawing-setup "A utility function to retrieve the drawing settings."
  [rows]
  (let [wh (* rows *size-cell)]
    (get-gfx wh wh)))
</pre>
</div>

<p>
To draw a cell, we need the color to paint the background of the cell and its coordinates:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn- draw-cell "Given a color and a cell's coordinate, draw the cell with the color 'col'"
  [gfx col y x]
  (.setColor gfx col)
  (.fillRect gfx
	     (* *size-cell x)
	     (+ *offset (* *size-cell y))
	     *size-cell *size-cell))
</pre>
</div>

<p>
The main function to draw the entire universe:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn draw "Draw the game of life"
  [gfx n u]
  (let [color {:dead java.awt.Color/WHITE
	       :live java.awt.Color/BLACK}
	r (range n)]
    (doseq [x r, y r]
      ;; clear the painting
      (draw-cell gfx (:dead color) x y)
      ;; optimisation for display
      (when (u [x y])
	;; draw the new state if needed
	(draw-cell gfx (:live color) x y)))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Sources</h3>
<div class="outline-text-3" id="text-2-7">
<p>
<a href="https://github.com/ardumont/clj-of-life/blob/master/src/clj_of_life/draw.clj">draw.clj</a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Start</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Let the game begin:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(defn game-of-life "Game of life: Given a number of rows, display a game of life with rows x rows frame."
  ([rows]
     (game-of-life rows (random-universe rows)))
  ([rows universe]
     (let [gfx (d/get-drawing-setup rows)]
       (iterate (fn [univ] (let [nxt-universe (next-state-universe univ)]
			 (do (d/draw gfx rows nxt-universe)
			     (Thread/sleep 300)
			     nxt-universe)))
		universe))))
</pre>
</div>

<p>
<b>Improvments</b> Make the game-of-life function a HOF to receive the draw function as parameter.
This way, we could change the rendering policy at will.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Run</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-clojure">clj-of-life.game&gt; (game-of-life 20) ;; launch a clj-of-life game with 20x20 frame
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Demo</h2>
<div class="outline-text-2" id="text-4">
<p>
<a href="https://www.youtube.com/watch?feature=player_detailpage&v=t0VODALOLxw#t=6s">https://www.youtube.com/watch?feature=player_detailpage&v=t0VODALOLxw#t=6s</a>
</p>
</div>
</div>

<p>
Since I like to try and solve problems, I thought of posting my solutions.
</p>

<p>
This may trigger some interesting discussions about how to improve the original algorithm.
</p>

<p>
Here is the exercise 171 of 4clojure about intervals.
</p>

<div class="blockquote">
<p>
Write a function that takes a sequence of integers and returns a sequence of "intervals".
Each interval is a a vector of two integers, start and end, such that all integers between start and end (inclusive) are contained in the input sequence.
</p>

</div>

<div class="org-src-container">

<pre class="src src-clojure">(ns ^{:doc "http://www.4clojure.com/problem/171#prob-title"}
  my-4clojure-lab.199.core171
  (:use [clojure.java.javadoc]
	[midje.sweet])
  (:require [clojure.tools.trace :as t]))

(defn intervals
  [v]
  (let [[f &amp; t] (sort v)]
    (if f
      (reverse
       (reduce
	(fn [[[a b] &amp; r :as l] e]
	  (if (&lt;= a e (+ 1 b))
	    (conj r [a e])
	    (conj l [e e])))
	[[f f]]
	t))
      v)))

(fact
  (intervals [1 2 3]) =&gt; [[1 3]]
  (intervals [10 9 8 1 2 3]) =&gt; [[1 3] [8 10]]
  (intervals [1 1 1 1 1 1 1]) =&gt; [[1 1]]
  (intervals []) =&gt; []
  (intervals [19 4 17 1 3 10 2 13 13 2 16 4 2 15 13 9 6 14 2 11]) =&gt; [[1 4] [6 6] [9 11] [13 17] [19 19]])
</pre>
</div>

<p>
<a href="https://github.com/ardumont/my-4clojure-lab/blob/master/src/my_4clojure_lab/199/core171.clj">source: 171.clj</a>
</p>

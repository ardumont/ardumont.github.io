<p>
I just wanted to try and learn the algorithm to encode a string in base64 and the other way around.
</p>

<p>
I used mainly wikipedia's <a href="https://en.wikipedia.org/wiki/Base64">english</a> and <a href="https://fr.wikipedia.org/wiki/Base64">french</a> version as source.
</p>

<p>
I hope you will enjoy this as much as I did.
</p>

<p>
Here are the sources and explanations.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Structure</h2>
<div class="outline-text-2" id="text-1">
<p>
I use 3 different namespaces.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">namespace</th>
<th scope="col" class="left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">base64</td>
<td class="left">main namespace for the encode and decode function</td>
</tr>

<tr>
<td class="left">dico</td>
<td class="left">the dictionary namespace holding the dictionary to encode and decode the characters</td>
</tr>

<tr>
<td class="left">binary</td>
<td class="left">number to bits and back manipulations</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Code</h2>
<div class="outline-text-2" id="text-2">
<p>
We'll go from the simpler to the hardest.
</p>

<p>
You'll find first the definition of the function and then the <b>fact(s)</b> (test from <a href="https://github.com/marick/midje">Midje</a> library) which are tests but also documentation about the use cases of the function.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Dico</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Just holding 2 hashmaps, <b>base64</b> to encode an ascii number into a char and <b>base64-dec</b> (which is the same map with keys and values transposed) to decode a char into a number.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(ns crypto.dico
  "A dictionary namespace"
  (:require [midje.sweet :as m]
	    [clojure.set :as set]))

(def ^{:doc "base64 dictionary to encode in base64"}
  base64 {0  \A
	  16 \Q
	  32 \g
	  48 \w
	  1  \B
	  17 \R
	  33 \h
	  49 \x
	  2  \C
	  18 \S
	  34 \i
	  50 \y
	  3  \D
	  19 \T
	  35 \j
	  51 \z
	  4  \E
	  20 \U
	  36 \k
	  52 \0
	  5  \F
	  21 \V
	  37 \l
	  53 \1
	  6  \G
	  22 \W
	  38 \m
	  54 \2
	  7  \H
	  23 \X
	  39 \n
	  55 \3
	  8  \I
	  24 \Y
	  40 \o
	  56 \4
	  9  \J
	  25 \Z
	  41 \p
	  57 \5
	  10 \K
	  26 \a
	  42 \q
	  58 \6
	  11 \L
	  27 \b
	  43 \r
	  59 \7
	  12 \M
	  28 \c
	  44 \s
	  60 \8
	  13 \N
	  29 \d
	  45 \t
	  61 \9
	  14 \O
	  30 \e
	  46 \u
	  62 \+
	  15 \P
	  31 \f
	  47 \v
	  63 \/})

(def ^{:doc "base64 dictionary to decode in base64"}
  base64-dec (set/map-invert base64))

(m/fact
  (set/map-invert base64)     =&gt; base64-dec
  (set/map-invert base64-dec) =&gt; base64)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Binary</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The binary namespace to help in transforming back and forth characters into sequence of bits.
</p>

<p>
I chose to represent the bits as big endian, so the bits sequence are read from the left to the right (big endian).
</p>

<p>
<span class="underline">Examples:</span>
[0 0 0 0 0 1 1 1] reads 7
[1 0 0 0 0 0 0 0] reads 128
</p>

<div class="org-src-container">

<pre class="src src-clojure">(ns crypto.binary
  "A binary namespace to deal with transformation into binary"
  (:use [midje.sweet :only [fact future-fact]]))

(defn- comp-bits-sequence
  "Complement a bits sequence by providing the policy through the complement-fn function."
  [n b complement-fn]
  (let [c (Math/abs (- n (count b)))]
    (if (= 0 c)
      b
      (-&gt;&gt; (repeat c 0)
	   (complement-fn b)))))

(m/fact
  (comp-bits-sequence 8  [1 1 1]           #(concat %2 %)) =&gt; [0 0 0 0 0 1 1 1]
  (comp-bits-sequence 8  [0 0 0 0 1 0 0 0] #(concat %2 %)) =&gt; [0 0 0 0 1 0 0 0]
  (comp-bits-sequence 4  [1 1 1]           #(concat %2 %)) =&gt; [0 1 1 1]
  (comp-bits-sequence 10 [0 0 0 0 1 0 0 0] #(concat %2 %)) =&gt; [0 0 0 0 0 0 1 0 0 0]
  (comp-bits-sequence 8  [1 1 1]           concat)         =&gt; [1 1 1 0 0 0 0 0]
  (comp-bits-sequence 8  [0 0 0 0 1 0 0 0] concat)         =&gt; [0 0 0 0 1 0 0 0]
  (comp-bits-sequence 4  [1 1 1]           concat)         =&gt; [1 1 1 0]
  (comp-bits-sequence 10 [0 0 0 0 1 0 0 0] concat)         =&gt; [0 0 0 0 1 0 0 0 0 0])

(defn comp-before
  "Complement by the most significant side (head) a bits sequence to n bits (if necessary)."
  [n b]
  (comp-bits-sequence n b (partial cons 0)))

(fact
  (comp-before 8 [1 1 1])            =&gt; [0 0 0 0 0 1 1 1]
  (comp-before 8 [0 0 0 0 1 0 0 0])  =&gt; [0 0 0 0 1 0 0 0]
  (comp-before 4 [1 1 1])            =&gt; [0 1 1 1]
  (comp-before 10 [0 0 0 0 1 0 0 0]) =&gt; [0 0 0 0 0 0 1 0 0 0])

(defn comp-after
  "Complement by the least significant side (tail) a bit sequence to n bits (if necessary)."
  [n b]
  (comp-bit-sequence n b #(concat % [0])))

(fact
  (comp-after 10 [1 1 1 1 1 1 1 1])  =&gt; [1 1 1 1 1 1 1 1 0 0]
  (comp-after 8 [1 1 1])            =&gt; [1 1 1 0 0 0 0 0]
  (comp-after 8 [0 0 0 0 1 0 0 0])  =&gt; [0 0 0 0 1 0 0 0]
  (comp-after 4 [1 1 1])            =&gt; [1 1 1 0]
  (comp-after 10 [0 0 0 0 1 0 0 0]) =&gt; [0 0 0 0 1 0 0 0 0 0])

(defn- bin
  "Convert a byte into binary sequence (will create as much bits as needed)."
  [b]
  (if (= 0 b)
    []
    (conj (-&gt; b (/ 2) int bin) (mod b 2))))

(fact
  (bin 97) =&gt; [1 1 0 0 0 0 1]
  (bin 2)  =&gt; [1 0])

(defn- to-binary
  "Given a number, compute a function permitting the translation into a n-bits sequence"
  [n]
  (comp (partial comp-before n) bin))

(fact
  ((to-binary 8) 97) =&gt; [0 1 1 0 0 0 0 1]
  ((to-binary 8) 2)  =&gt; [0 0 0 0 0 0 1 0])

(def to-8bits ^{:doc "Given a number, compute its 8-bits representation."}
  (to-binary 8))

(fact
  (to-8bits 97) =&gt; [0 1 1 0 0 0 0 1]
  (to-8bits 2)  =&gt; [0 0 0 0 0 0 1 0])

(def to-6bits ^{:doc "Given a number, compute its 6-bits representation."}
  (to-binary 6))

(fact
  (to-6bits 26) =&gt; [0 1 1 0 1 0]
  (to-6bits 1)  =&gt; [0 0 0 0 0 1]
  (to-6bits 2)  =&gt; [0 0 0 0 1 0]
  (to-6bits 3)  =&gt; [0 0 0 0 1 1])

(defn to-num
  "Convert a bit sequence into a number"
  [b]
  (-&gt;&gt; (reverse b)
       (map-indexed (fn [i v] [(Math/pow 2 i) v]))
       (reduce (fn [a [e n]] (if (= n 1) (+ e a) a)) 0)
       int))

(fact
  (to-num [1 1 0 0 0 0 1])   =&gt; 97
  (to-num [0 1 1 0 0 0 0 1]) =&gt; 97
  (to-num [0 0 0 0 0 0 1 0]) =&gt; 2
  (to-num [0 0 0 0 0 0 0 0]) =&gt; 0
  (to-num [1 1 1 1 1 1 1 1]) =&gt; 255
  (to-num [1 1 1 1 1 1 1 0]) =&gt; 254)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Base64</h3>
<div class="outline-text-3" id="text-2-3">
<p>
At last, the main namespace holding the functions:
</p>
<ul class="org-ul">
<li>encode which takes a string and returns a base64 string
</li>
<li>decode which takes a base64 string and returns an ascii string.
</li>
</ul>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Encode</h4>
<div class="outline-text-4" id="text-2-3-1">
</div><div id="outline-container-sec-2-3-1-1" class="outline-5">
<h5 id="sec-2-3-1-1">Utilities</h5>
<div class="outline-text-5" id="text-2-3-1-1">
<div class="org-src-container">

<pre class="src src-clojure">(ns crypto.base64
  "encode and decode a string in base64"
  (:use [midje.sweet :only [fact]])
  (:require [crypto-challenge.dico   :as d]
	    [crypto-challenge.binary :as b]
	    [clojure.string          :as s]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; encoding

;; Given a partition of 24 bits, compute the complement [partition of multiple 6 bits, list of complement = char]
(defmulti comp24 count)

;; complement 4 bits to be able to have 2 bytes (12 bits) and we complements with 2 = chars
(defmethod comp24 8 [b] [(b/comp-after 12 b)
			 [\= \=]])

(fact
  (comp24 [1 1 1 1 1 1 1 1]) =&gt; [[1 1 1 1 1 1,
				  1 1 0 0 0 0]
				 [\= \=]])

;; complement 2 bits to be able to have 3 bytes (18 bits) and we complements with 1 = char
(defmethod comp24 16 [b] [(b/comp-after 18 b)
			  [\=]])

(fact
  (comp24 [1 1 1 1 1 1 1 1, 0 0 0 0 0 0 1 1]) =&gt; [[1 1 1 1 1 1,
						   1 1 0 0 0 0,
						   0 0 1 1 0 0]
						  [\=]])

;; chunk of 24 remains the same without any complement
(defmethod comp24 :default [b] [b []])

(fact
  (comp24 [1 1 1 1 1 1 1 1, 0 0 0 0 0 0 1 1, 1 1 1 1 1 1 1 1]) =&gt; [[1 1 1 1 1 1,
								    1 1 0 0 0 0,
								    0 0 1 1 1 1,
								    1 1 1 1 1 1]
								   []])

(def char2bits ^{:doc "Convert a char into a 8-bits sequence"}
  (comp b/to-8bits int))

(fact
  (char2bits \a) =&gt; [0 1 1 0 0 0 0 1])

(def bits2char ^{:doc "Convert a 8-bits sequence into a char"}
  (comp char b/to-num))

(fact
  (bits2char [0 1 1 0 0 0 0 1]) =&gt; \a)

(def to-bits ^{:private true
	       :doc "Transform a string into a list of bits."}
  (partial mapcat char2bits))

(fact
  (to-bits [\a \b \c]) =&gt; [0 1 1 0 0 0 0 1,
			   0 1 1 0 0 0 1 0,
			   0 1 1 0 0 0 1 1]
  (to-bits "haskell")  =&gt; [0 1 1 0 1 0 0 0,
			   0 1 1 0 0 0 0 1,
			   0 1 1 1 0 0 1 1,
			   0 1 1 0 1 0 1 1,
			   0 1 1 0 0 1 0 1,
			   0 1 1 0 1 1 0 0,
			   0 1 1 0 1 1 0 0])

(defn to-base64
  "Given a 8 or 16 or 24-bits chunk, compute the bits sequence into base64."
  [b]
  (let [[part complement] (comp24 b)
	p24               (-&gt;&gt; part
			       (partition 6)
			       (map (comp d/base64 b/to-num)))]
    (concat p24 complement)))

(fact
  (to-base64 [1 1 1 1 1 1, 1 1 0 0 0 0])                           =&gt; [\/ \w]
  (to-base64 [1 1 1 1 1 1, 1 1 0 0 0 0, 0 0 1 1 0 0])              =&gt; [\/ \w \M]
  (to-base64 [1 1 1 1 1 1, 1 1 0 0 0 0, 0 0 1 1 1 1, 1 1 1 1 1 1]) =&gt; [\/ \w \P \/])
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-1-2" class="outline-5">
<h5 id="sec-2-3-1-2">Algorithm</h5>
<div class="outline-text-5" id="text-2-3-1-2">
<ul class="org-ul">
<li>Transform the string into 8-bits binary sequence
</li>
<li>Partition into chunks of 24 bits
</li>
<li>Encode each 6 bits into base64 (so 3 chars in ascii give 4 chars in base64)
</li>
</ul>
<p>
Beware, there is a subtlety regarding the last chunk which can have 8, 16 (in those case, there is the complement =) or 24 bits.
</p>
<ul class="org-ul">
<li>Join the string and you have the result
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(defn encode
  "Encode into base64"
  [s]
  (-&gt;&gt; s
       to-bits            ;; Transform all chars into 8-bits sequence
       (partition-all 24) ;; 24-bits chunks
       (mapcat to-base64) ;; deal with the last chunk of bits (which can be of size 8, 16 or 24)
       (s/join "")))

(fact
  (encode "Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.")
  =&gt; "TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=")
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">decode</h4>
<div class="outline-text-4" id="text-2-3-2">
</div><div id="outline-container-sec-2-3-2-1" class="outline-5">
<h5 id="sec-2-3-2-1">Utility</h5>
<div class="outline-text-5" id="text-2-3-2-1">
<div class="org-src-container">

<pre class="src src-clojure">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; decoding

(def decode-b64char ^{:doc "Decode a 8-bit base64 representation into a 6-bits representation."}
  (comp b/to-6bits d/base64-dec))

(fact
  (decode-b64char \a) =&gt; [0 1 1 0 1 0]
  (decode-b64char \b) =&gt; [0 1 1 0 1 1])

(defn decode4
  "Decode 4 characters into 3 bytes (24 bits)"
  [s]
  (-&gt;&gt; s
       (take-while #(not= \= %))
       (mapcat decode-b64char)))

(fact
  (decode4 "ab==") =&gt; [0 1 1 0 1 0,
		       0 1 1 0 1 1]
  (decode4 "ba==") =&gt; [0 1 1 0 1 1,
		       0 1 1 0 1 0])
(fact
  (decode4 "aab=") =&gt; [0 1 1 0 1 0,
		       0 1 1 0 1 0,
		       0 1 1 0 1 1]
  (decode4 "abb=") =&gt; [0 1 1 0 1 0,
		       0 1 1 0 1 1,
		       0 1 1 0 1 1])
(fact
  (decode4 "aaaa") =&gt; [0 1 1 0 1 0,
		       0 1 1 0 1 0,
		       0 1 1 0 1 0,
		       0 1 1 0 1 0]
  (decode4 "abaa") =&gt; [0 1 1 0 1 0,
		       0 1 1 0 1 1,
		       0 1 1 0 1 0,
		       0 1 1 0 1 0]
  (decode4 "aaba") =&gt; [0 1 1 0 1 0,
		       0 1 1 0 1 0,
		       0 1 1 0 1 1,
		       0 1 1 0 1 0]
  (decode4 "aaab") =&gt; [0 1 1 0 1 0,
		       0 1 1 0 1 0,
		       0 1 1 0 1 0,
		       0 1 1 0 1 1])
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3-2-2" class="outline-5">
<h5 id="sec-2-3-2-2">Algorithm</h5>
<div class="outline-text-5" id="text-2-3-2-2">
<ul class="org-ul">
<li>partition the string into chunk of 4 characters
</li>
<li>decode those chunk into 3 bytes (24 bits sequence).
</li>
</ul>
<p>
Here again, there is the subtlety regarding the = complement character.
Those = characters are only complements to fill in the gap in the string.
So for the decoding, we just drop them (see decode-b64char function for more details).
</p>
<ul class="org-ul">
<li>partition into 8-bits sequence
</li>
<li>transform those bits
</li>
</ul>

<div class="org-src-container">

<pre class="src src-clojure">(defn decode
  "Decode base64 message"
  [s]
  (-&gt;&gt; s
       (partition 4)    ;; 4 words (32 bits)
       (mapcat decode4) ;; decoded into 3 bytes (24 bits)
       (partition 8)    ;; spliced into byte word (8 bits)
       (map bits2char)  ;; converted back into char
       (s/join "")))    ;; then joined to form a string

(fact
  (decode "TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=")
  =&gt;  "Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure."

  (decode "YW55IGNhcm5hbCBwbGVhcw==") =&gt; "any carnal pleas"
  (decode "YW55IGNhcm5hbCBwbGVhc3U=") =&gt; "any carnal pleasu"
  (decode "YW55IGNhcm5hbCBwbGVhc3Vy") =&gt; "any carnal pleasur")
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Sources</h2>
<div class="outline-text-2" id="text-3">
<p>
<a href="https://github.com/ardumont/crypto/tree/95276307cff3f98326745f8bf6ff3699129640b7">sources</a>
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Conclusion</h2>
<div class="outline-text-2" id="text-4">
<p>
I had fun even playing (again) with bits (surely, I could have reused some code that I'm not aware of!)
</p>

<p>
Coding/Programming/Developing is fun!
</p>

<p>
To sum up, "Just code it!"
</p>
</div>
</div>

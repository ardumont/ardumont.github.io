<p>
Now that i know a little more about haskell, I can go and refresh my memory about algorithms but the functional way.
So, I came accross functional approach in haskell which does exactly that.
</p>

<p>
Here are the first exercises (focused on haskell for the moment).
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Simple</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
Using a haskell interpreter, evaluate the following expressions (try to predict the result):
(1+2)
if (2 &gt; 9) then "hello" else "bye"
let x=(sqrt 16) in x+1
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">(1+2)                               - 3
if (2 &gt; 9) then "hello" else "bye"  - "bye"
let x=(sqrt 16) in x+1              -  5.0
</pre>
</div>

<p>
Interpreter:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; 1 + 2
3
*Ch1&gt; if (2 &gt; 9) then "hello" else "bye"
"bye"
*Ch1&gt; let x=(sqrt 16) in x+1
5.0
</pre>
</div>

<p>
*
</p>
<blockquote>
<p>
Define and load the following function:
<code>fact 1 = 1</code>
<code>fact n = n * fact (n-1)</code>
</p>

<p>
a) Using the interpreter, evaluate the expression <code>fact 5</code>
b) What happens when you try to evaluate <code>fact 0</code>? Alter the above definition to solve this definition.
c) Modify your definition such that the value -1 is returned when an attempt is made to compute the factorial of a negative value.
</p>
</blockquote>

<p>
a)
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; fact 5
120
</pre>
</div>

<p>
b)
</p>
<ul class="org-ul">
<li>the function does not terminate
</li>
<li>alter:
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell">fact :: Int -&gt; Int
fact 0 = 1
fact n = n * fact (n-1)
</pre>
</div>

<p>
c)
Compute factorial of a negative value must render -1:
</p>
<div class="org-src-container">

<pre class="src src-haskell">fact :: Int -&gt; Int
fact n
  | n &lt; 0     = -1
  | n == 0    = 1
  | otherwise = n * fact (n-1)

*Ch1&gt; fact 0
1
*Ch1&gt; fact 1
1
*Ch1&gt; fact 5
120
*Ch1&gt; fact (-10)
-1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">wrong</h2>
<div class="outline-text-2" id="text-2">
<blockquote>
<p>
What is wrong with the following expressions? Can you change them to make them valid?
</p>

<p>
1:2:3
[ [2,3] ++ [], [2,3]:[] ]
"hello" : "world"
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; (1:2:3:[])
[1,2,3]
*Ch1&gt; [[[2,3] ++ []], ([2,3]:[])]
[[[2,3]],[[2,3]]]
*Ch1&gt; "hello" ++ "world"
"helloworld"
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">reverse</h2>
<div class="outline-text-2" id="text-3">
<blockquote>
<p>
Given the following function:
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-haskell">f l = reverse (f' l [])
      where f' [] r     = r
	    f' (x:xs) r = (2*x) : (f' xs r)
</pre>
</div>
<blockquote>
<p>
What is the value of <code>f [1,2,3,4])</code> ?
Check your answer with the haskell interpreter.
</p>
</blockquote>

<p>
Answer step by step:
</p>
<div class="org-src-container">

<pre class="src src-haskell">f [1,2,3,4] = reverse (f' [1,2,3,4] [])
	    = reverse ((2*1) : (f' [2,3,4] []))
	    = reverse (2 : (2*2) : (f' [3,4] []))
	    = reverse (2 : 4 : (2*3) : (f' [4] []))
	    = reverse (2 : 4 : 6 : (4*2) : (f' [] []))
	    = reverse (2 : 4 : 6 : 8 : [])
	    = [8,6,4,2]
</pre>
</div>

<p>
Interpreter:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; f [1..4]
[8,6,4,2]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Predict</h2>
<div class="outline-text-2" id="text-4">
<blockquote>
<p>
Try to predict the value of the following expressions:
<code>[1,2,3] ++ [4]</code>
<code>1:(2:(3:[4]))</code>
<code>head [1,2,3]</code>
<code>tail [1,2,3]</code>
<code>drop 4 [1,2,3,4,5]</code>
<code>[1,2,3,4] !! 2</code>
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">[1,2,3] ++ [4]          -- [1,2,3,4]
1:(2:(3:[4]))           -- [1,2,3,4]
head [1,2,3]            -- 1
tail [1,2,3]            -- [2,3]
drop 4 [1,2,3,4,5]      -- [5]
[1,2,3,4] !! 2          -- 3
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">functions</h2>
<div class="outline-text-2" id="text-5">
<blockquote>
<p>
Write Haskell functions for:
a) computing the average value of a list of numbers;
b) selecting the middle element in a list (assuming an odd-length list).
</p>
</blockquote>

<p>
a)
</p>
<div class="org-src-container">

<pre class="src src-haskell">avg :: [Int] -&gt; Int
avg xs | null xs   = 0
       | otherwise = (sum xs) `div` (length xs)

*Ch1&gt; avg [1..10]
5
*Ch1&gt; avg []
0
</pre>
</div>

<p>
b)
</p>
<div class="org-src-container">

<pre class="src src-haskell">mdl :: [a] -&gt; Maybe a
mdl xs | null xs   = Nothing
       | otherwise = Just (xs !! p)
		     where p = ((subtract 1) . (`div` 2) . length) xs

*Ch1&gt; mdl [1..10]
Just 5
*Ch1&gt; mdl [1..20]
Just 10
*Ch1&gt; mdl []
Nothing
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">predict</h2>
<div class="outline-text-2" id="text-6">
<blockquote>
<p>
a) Try to predict the value of each of the following expressions:
<code>[(x,y) | x &lt;- [1..2], y &lt;- [2..5], (x+y) /</code> 4]=
<code>[x | x &lt;- [1..10], x `mod` 2 =</code> 0]=
</p>
</blockquote>

<p>
All the couple (x,y), such that x in [1,2] and y in [2,3,4,5) and that x+y is not 4:
</p>
<div class="org-src-container">

<pre class="src src-haskell">[(x,y) | x &lt;- [1..2], y &lt;- [2..5], (x+y) /= 4] -- [(1,2), (1,4), (1,5),
						   (2,3), (2,4), (2,5)]
</pre>
</div>

<p>
All even numbers in [1..10]:
</p>
<div class="org-src-container">

<pre class="src src-haskell">[x | x &lt;- [1..10], x `mod` 2 == 0] = [2,4,6,8,10]
</pre>
</div>

<p>
Interpreter:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; [(x,y) | x &lt;- [1..2], y &lt;- [2..5], (x+y) /= 4]
[(1,2),(1,4),(1,5),(2,3),(2,4),(2,5)]
*Ch1&gt; [x | x &lt;- [1..10], x `mod` 2 == 0]
[2,4,6,8,10]
</pre>
</div>

<blockquote>
<p>
b) Define each of the following lists using a list comprehension:
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
[2,-3,4,-5,6,-7,8,-9,10,-11]
</p>
</blockquote>

<p>
Answer:
</p>
<div class="org-src-container">

<pre class="src src-haskell">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] = [1..15]
				      =  [x | x &lt;- [1..15]]

*Ch1&gt; [x | x &lt;- [1..15]]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">[2,-3,4,-5,6,-7,8,-9,10,-11] = [ if odd x then -1 * x else x | x &lt;- [2..11]]

*Ch1&gt; [ if odd x then -1 * x else x | x &lt;- [2..11]]
[2,-3,4,-5,6,-7,8,-9,10,-11]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">list comprehension</h2>
<div class="outline-text-2" id="text-7">
<blockquote>
<p>
a) Using a list comprehension, define a function neg that counts the number of negative values in a list. For example:
<code>neg [1, -9, 5, 4, -6, 0] = 3</code>
b) Using a list comprehension, define the function rep that takes an argument n and returns a list in which 1 occurs one time, 2 occurs 2 two and so one until n occurs n time. For example:
=rep 4 =&gt; [1,2,2,3,3,3,4,4,4,4]
</p>
</blockquote>

<p>
a)
</p>

<div class="org-src-container">

<pre class="src src-haskell">neg :: [Int] -&gt; Int
neg xs = sum [1 | x &lt;- xs, x &lt; 0 ]

*Ch1&gt; neg [1, -9, -5, 4, -6, 0]
3
</pre>
</div>

<p>
b)
</p>
<div class="org-src-container">

<pre class="src src-haskell">rep :: Int -&gt; [Int]
rep n = [ y | x &lt;- [1..n], y &lt;- replicate x x]

*Ch1&gt; rep 0
[]
*Ch1&gt; rep 1
[1]
*Ch1&gt; rep 2
[1,2,2]
*Ch1&gt; rep 3
[1,2,2,3,3,3]
*Ch1&gt; rep 4
[1,2,2,3,3,3,4,4,4,4]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">string2int</h2>
<div class="outline-text-2" id="text-8">
<blockquote>
<p>
Define a function <code>string2int</code> that converts a string of digits into the corresponding integer.
For example:
string2int "3454" = 3454
string2int "76"   = 76
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">string2int :: String -&gt; Int
string2int xs = sum [ ((* u) . digitToInt) x | (u, x) &lt;- zip unit (reverse xs)]
		where unit = iterate (* 10) 1

*Ch1&gt; string2int "123"
123
*Ch1&gt; string2int "3434"
3434
*Ch1&gt; string2int "3454"
3454
*Ch1&gt; string2int "76"
76
</pre>
</div>

<p>
Or we could use the standard function <code>read :: Read a =&gt; String -&gt; a</code>
</p>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Predict</h2>
<div class="outline-text-2" id="text-9">
<blockquote>
<p>
Try to predict the values of the following expressions:
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-haskell">map fst [(1,2), (3,8), (0,6), (3,1)]

(foldr f 0 l, foldl f 0 l)
  where l = [6,9,8,3,10]
	f x y = (x+y) `div` 2

foldr (++) [] [[1,2,3], [4,5,6], [], [7]]
</pre>
</div>

<p>
a)
</p>

<p>
Recall the definition of:
</p>
<div class="org-src-container">

<pre class="src src-haskell">fst :: (a,b) -&gt; a
fst (x,_) = x

map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ []     = []
map f (x:xs) = f x : map f xs

-- or using list comprehension:
map f xs = [ f x | x &lt;- xs]
</pre>
</div>

<p>
We can then conclude:
</p>
<div class="org-src-container">

<pre class="src src-haskell">map fst [(1,2), (3,8), (0,6), (3,1)] = [1,3,0,3]
</pre>
</div>

<p>
b)
Again recall the definition of foldr:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr _ x []     = x
foldr f x (y:ys) = f y $ foldr f x ys
</pre>
</div>

<p>
Thus:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foldr f 0 l = foldr f 0 [6,9,8,3,10]
	    = f 6 (foldr f 0 [9,8,3,10])
	    = f 6 (f 9 (foldr f 0 [8,3,10]))
	    = ...
	    = f 6 (f 9 (f 8 (f 3 (f 10 0))))
	    = f 6 (f 9 (f 8 (f 3 (10+0 `div` 2))))
	    = f 6 (f 9 (f 8 (f 3 5)))
	    = f 6 (f 9 (f 8 (3 + 4 `div` 2)))
	    = f 6 (f 9 (f 8 3))
	    = f 6 (f 9 5)
	    = f 6 7
	    = 6
</pre>
</div>

<p>
Now the right operand, using foldl as operations:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
foldl _ x []     = x
foldl f x (y:ys) = foldl f (f x y) ys
</pre>
</div>

<p>
Thus (I do not forget that haskell is lazy, just bear with me)
</p>
<div class="org-src-container">

<pre class="src src-haskell">foldl f 0 l = foldl f 0        [6,9,8,3,10]
	    = foldl f (f 0 6)  [9,8,3,10]
	    = foldl f (f 1 9)  [8,3,10]
	    = foldl f (f 5 8)  [3,10]
	    = foldl f (f 6 3)  [10]
	    = foldl f (f 5 10) []
	    = foldl f 7        []
	    = 7
</pre>
</div>

<p>
to conclude:
</p>
<div class="org-src-container">

<pre class="src src-haskell">(foldr f 0 l, foldl f 0 l)
  where l = [6,9,8,3,10]
	f x y = (x+y) `div` 2 -- (6,7)
</pre>
</div>

<p>
Indeed:
</p>
<div class="org-src-container">

<pre class="src src-haskell">tmp :: (Integer, Integer)
tmp = (foldr f 0 l, foldl f 0 l)
  where l = [6,9,8,3,10]
	f x y = (x+y) `div` 2

*Ch1&gt; tmp
(6,7)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">type</h2>
<div class="outline-text-2" id="text-10">
<blockquote>
<p>
What is the type of the following function?
<code>compose f g x = f (g x)</code>
</p>
</blockquote>

<p>
As we can see from the definition of compose:
</p>
<ul class="org-ul">
<li>f and g takes one parameter each.
</li>
<li>f takes the output type of g as input.
</li>
</ul>

<p>
We can sum up the definition of g and f:
</p>
<div class="org-src-container">

<pre class="src src-haskell">g :: a -&gt; b
f :: b -&gt; c
</pre>
</div>

<p>
Thus:
</p>
<div class="org-src-container">

<pre class="src src-haskell">compose :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</pre>
</div>

<p>
Check:
</p>

<div class="org-src-container">

<pre class="src src-haskell">compose :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
compose f g x = f (g x)
</pre>
</div>

<p>
Using <code>compose</code>, we could redefine the <code>string2int</code> function from earlier:
</p>
<div class="org-src-container">

<pre class="src src-haskell">string2int' :: String -&gt; Int
string2int' xs = sum [ compose (* u) digitToInt x | (u, x) &lt;- zip unit (reverse xs)]
		 where unit = iterate (* 10) 1
</pre>
</div>

<p>
The standard composition function is (.)
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; :t (.)
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">matrix</h2>
<div class="outline-text-2" id="text-11">
<blockquote>
<p>
Given the matrix:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">2 3 4</td>
</tr>

<tr>
<td class="left">5 6 7</td>
</tr>

<tr>
<td class="left">8 9 10</td>
</tr>
</tbody>
</table>
<p>
a) Define a function that transposes a square matrix of size 3.
If applied to the previous matrix, the result should be:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">2 5 8</td>
</tr>

<tr>
<td class="left">3 6 9</td>
</tr>

<tr>
<td class="left">4 7 10</td>
</tr>
</tbody>
</table>
<p>
b) Extends this definition for a matrix of any size
</p>
</blockquote>

<p>
a)
</p>
<div class="org-src-container">

<pre class="src src-haskell">transpose3 :: [[a]] -&gt; [[a]]
transpose3 xs = map (\ n -&gt; map (!! n) xs) [0..2]

*Ch1&gt; transpose3 [[1,2,3], [4,5,6], [7,8,9]]
[[1,4,7],[2,5,8],[3,6,9]]
</pre>
</div>

<p>
b)
</p>
<div class="org-src-container">

<pre class="src src-haskell">transpose :: [[a]] -&gt; [[a]]
transpose xs = map (\ n -&gt; map (!! n) xs) [0..l]
	       where l = length xs - 1

*Ch1&gt; transpose [[1,2,3], [4,5,6], [7,8,9]]
[[1,4,7],[2,5,8],[3,6,9]]
*Ch1&gt; transpose [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]]
[[1,5,9,13],[2,6,10,14],[3,7,11,15],[4,8,12,16]]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">type</h2>
<div class="outline-text-2" id="text-12">
<p>
Determine the type definitions (with the context) of the following functions:
</p>
<div class="org-src-container">

<pre class="src src-haskell">cube x = x * x * x

maxi x y | x &gt;= y = x
	 | otherwise = y

sumAtoB a b = sum [a..b]
</pre>
</div>

<p>
We must be able to compute the multiplication on x, so this must be of type Num.
</p>
<div class="org-src-container">

<pre class="src src-haskell">cube :: Num a =&gt; a -&gt; a
cube x = x * x * x
</pre>
</div>

<p>
We must be able to compare the number, so type Ord.
</p>
<div class="org-src-container">

<pre class="src src-haskell">maxi :: (Ord a) =&gt; a -&gt; a -&gt; a
maxi x y | x &gt;= y = x
	 | otherwise = y
</pre>
</div>

<p>
We must be able to compute the sum, so Num type and use a list comprehension, so Enum type.
</p>
<div class="org-src-container">

<pre class="src src-haskell">sumAtoB :: (Num a, Enum a) =&gt; a -&gt; a -&gt; a
sumAtoB a b = sum [a..b]
</pre>
</div>
</div>
</div>

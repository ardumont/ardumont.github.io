<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Functional Approach in haskell - Ch2 - Exercises</title>
<!-- 2014-12-02 Tue 18:41 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Antoine R. Dumont" />
<meta  name="description" content="Functional Approach in Haskell - Ch. 2 - Functional programming in Haskell - exercises"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="./other/style.css" type="text/css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Functional Approach in haskell - Ch2 - Exercises</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Simple</a></li>
<li><a href="#sec-2">wrong</a></li>
<li><a href="#sec-3">reverse</a></li>
<li><a href="#sec-4">Predict</a></li>
<li><a href="#sec-5">functions</a></li>
<li><a href="#sec-6">predict</a></li>
<li><a href="#sec-7">list comprehension</a></li>
<li><a href="#sec-8">string2int</a></li>
<li><a href="#sec-9">Predict</a></li>
<li><a href="#sec-10">type</a></li>
<li><a href="#sec-11">matrix</a></li>
<li><a href="#sec-12">type</a></li>
</ul>
</div>
</div>
<p>
Now that i know a little more about haskell, I can go and refresh my memory about algorithms but the functional way.
So, I came accross functional approach in haskell which does exactly that.
</p>

<p>
Here are the first exercises (focused on haskell for the moment).
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Simple</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
Using a haskell interpreter, evaluate the following expressions (try to predict the result):
(1+2)
if (2 &gt; 9) then "hello" else "bye"
let x=(sqrt 16) in x+1
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">(1+2)                               - 3
if (2 &gt; 9) then "hello" else "bye"  - "bye"
let x=(sqrt 16) in x+1              -  5.0
</pre>
</div>

<p>
Interpreter:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; 1 + 2
3
*Ch1&gt; if (2 &gt; 9) then "hello" else "bye"
"bye"
*Ch1&gt; let x=(sqrt 16) in x+1
5.0
</pre>
</div>

<p>
*
</p>
<blockquote>
<p>
Define and load the following function:
<code>fact 1 = 1</code>
<code>fact n = n * fact (n-1)</code>
</p>

<p>
a) Using the interpreter, evaluate the expression <code>fact 5</code>
b) What happens when you try to evaluate <code>fact 0</code>? Alter the above definition to solve this definition.
c) Modify your definition such that the value -1 is returned when an attempt is made to compute the factorial of a negative value.
</p>
</blockquote>

<p>
a)
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; fact 5
120
</pre>
</div>

<p>
b)
</p>
<ul class="org-ul">
<li>the function does not terminate
</li>
<li>alter:
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell">fact :: Int -&gt; Int
fact 0 = 1
fact n = n * fact (n-1)
</pre>
</div>

<p>
c)
Compute factorial of a negative value must render -1:
</p>
<div class="org-src-container">

<pre class="src src-haskell">fact :: Int -&gt; Int
fact n
  | n &lt; 0     = -1
  | n == 0    = 1
  | otherwise = n * fact (n-1)

*Ch1&gt; fact 0
1
*Ch1&gt; fact 1
1
*Ch1&gt; fact 5
120
*Ch1&gt; fact (-10)
-1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">wrong</h2>
<div class="outline-text-2" id="text-2">
<blockquote>
<p>
What is wrong with the following expressions? Can you change them to make them valid?
</p>

<p>
1:2:3
[ [2,3] ++ [], [2,3]:[] ]
"hello" : "world"
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; (1:2:3:[])
[1,2,3]
*Ch1&gt; [[[2,3] ++ []], ([2,3]:[])]
[[[2,3]],[[2,3]]]
*Ch1&gt; "hello" ++ "world"
"helloworld"
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">reverse</h2>
<div class="outline-text-2" id="text-3">
<blockquote>
<p>
Given the following function:
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-haskell">f l = reverse (f' l [])
      where f' [] r     = r
	    f' (x:xs) r = (2*x) : (f' xs r)
</pre>
</div>
<blockquote>
<p>
What is the value of <code>f [1,2,3,4])</code> ?
Check your answer with the haskell interpreter.
</p>
</blockquote>

<p>
Answer step by step:
</p>
<div class="org-src-container">

<pre class="src src-haskell">f [1,2,3,4] = reverse (f' [1,2,3,4] [])
	    = reverse ((2*1) : (f' [2,3,4] []))
	    = reverse (2 : (2*2) : (f' [3,4] []))
	    = reverse (2 : 4 : (2*3) : (f' [4] []))
	    = reverse (2 : 4 : 6 : (4*2) : (f' [] []))
	    = reverse (2 : 4 : 6 : 8 : [])
	    = [8,6,4,2]
</pre>
</div>

<p>
Interpreter:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; f [1..4]
[8,6,4,2]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Predict</h2>
<div class="outline-text-2" id="text-4">
<blockquote>
<p>
Try to predict the value of the following expressions:
<code>[1,2,3] ++ [4]</code>
<code>1:(2:(3:[4]))</code>
<code>head [1,2,3]</code>
<code>tail [1,2,3]</code>
<code>drop 4 [1,2,3,4,5]</code>
<code>[1,2,3,4] !! 2</code>
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">[1,2,3] ++ [4]          -- [1,2,3,4]
1:(2:(3:[4]))           -- [1,2,3,4]
head [1,2,3]            -- 1
tail [1,2,3]            -- [2,3]
drop 4 [1,2,3,4,5]      -- [5]
[1,2,3,4] !! 2          -- 3
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">functions</h2>
<div class="outline-text-2" id="text-5">
<blockquote>
<p>
Write Haskell functions for:
a) computing the average value of a list of numbers;
b) selecting the middle element in a list (assuming an odd-length list).
</p>
</blockquote>

<p>
a)
</p>
<div class="org-src-container">

<pre class="src src-haskell">avg :: [Int] -&gt; Int
avg xs | null xs   = 0
       | otherwise = (sum xs) `div` (length xs)

*Ch1&gt; avg [1..10]
5
*Ch1&gt; avg []
0
</pre>
</div>

<p>
b)
</p>
<div class="org-src-container">

<pre class="src src-haskell">mdl :: [a] -&gt; Maybe a
mdl xs | null xs   = Nothing
       | otherwise = Just (xs !! p)
		     where p = ((subtract 1) . (`div` 2) . length) xs

*Ch1&gt; mdl [1..10]
Just 5
*Ch1&gt; mdl [1..20]
Just 10
*Ch1&gt; mdl []
Nothing
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">predict</h2>
<div class="outline-text-2" id="text-6">
<blockquote>
<p>
a) Try to predict the value of each of the following expressions:
<code>[(x,y) | x &lt;- [1..2], y &lt;- [2..5], (x+y) /</code> 4]=
<code>[x | x &lt;- [1..10], x `mod` 2 =</code> 0]=
</p>
</blockquote>

<p>
All the couple (x,y), such that x in [1,2] and y in [2,3,4,5) and that x+y is not 4:
</p>
<div class="org-src-container">

<pre class="src src-haskell">[(x,y) | x &lt;- [1..2], y &lt;- [2..5], (x+y) /= 4] -- [(1,2), (1,4), (1,5),
						   (2,3), (2,4), (2,5)]
</pre>
</div>

<p>
All even numbers in [1..10]:
</p>
<div class="org-src-container">

<pre class="src src-haskell">[x | x &lt;- [1..10], x `mod` 2 == 0] = [2,4,6,8,10]
</pre>
</div>

<p>
Interpreter:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; [(x,y) | x &lt;- [1..2], y &lt;- [2..5], (x+y) /= 4]
[(1,2),(1,4),(1,5),(2,3),(2,4),(2,5)]
*Ch1&gt; [x | x &lt;- [1..10], x `mod` 2 == 0]
[2,4,6,8,10]
</pre>
</div>

<blockquote>
<p>
b) Define each of the following lists using a list comprehension:
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
[2,-3,4,-5,6,-7,8,-9,10,-11]
</p>
</blockquote>

<p>
Answer:
</p>
<div class="org-src-container">

<pre class="src src-haskell">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15] = [1..15]
				      =  [x | x &lt;- [1..15]]

*Ch1&gt; [x | x &lt;- [1..15]]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell">[2,-3,4,-5,6,-7,8,-9,10,-11] = [ if odd x then -1 * x else x | x &lt;- [2..11]]

*Ch1&gt; [ if odd x then -1 * x else x | x &lt;- [2..11]]
[2,-3,4,-5,6,-7,8,-9,10,-11]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">list comprehension</h2>
<div class="outline-text-2" id="text-7">
<blockquote>
<p>
a) Using a list comprehension, define a function neg that counts the number of negative values in a list. For example:
<code>neg [1, -9, 5, 4, -6, 0] = 3</code>
b) Using a list comprehension, define the function rep that takes an argument n and returns a list in which 1 occurs one time, 2 occurs 2 two and so one until n occurs n time. For example:
=rep 4 =&gt; [1,2,2,3,3,3,4,4,4,4]
</p>
</blockquote>

<p>
a)
</p>

<div class="org-src-container">

<pre class="src src-haskell">neg :: [Int] -&gt; Int
neg xs = sum [1 | x &lt;- xs, x &lt; 0 ]

*Ch1&gt; neg [1, -9, -5, 4, -6, 0]
3
</pre>
</div>

<p>
b)
</p>
<div class="org-src-container">

<pre class="src src-haskell">rep :: Int -&gt; [Int]
rep n = [ y | x &lt;- [1..n], y &lt;- replicate x x]

*Ch1&gt; rep 0
[]
*Ch1&gt; rep 1
[1]
*Ch1&gt; rep 2
[1,2,2]
*Ch1&gt; rep 3
[1,2,2,3,3,3]
*Ch1&gt; rep 4
[1,2,2,3,3,3,4,4,4,4]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">string2int</h2>
<div class="outline-text-2" id="text-8">
<blockquote>
<p>
Define a function <code>string2int</code> that converts a string of digits into the corresponding integer.
For example:
string2int "3454" = 3454
string2int "76"   = 76
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">string2int :: String -&gt; Int
string2int xs = sum [ ((* u) . digitToInt) x | (u, x) &lt;- zip unit (reverse xs)]
		where unit = iterate (* 10) 1

*Ch1&gt; string2int "123"
123
*Ch1&gt; string2int "3434"
3434
*Ch1&gt; string2int "3454"
3454
*Ch1&gt; string2int "76"
76
</pre>
</div>

<p>
Or we could use the standard function <code>read :: Read a =&gt; String -&gt; a</code>
</p>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Predict</h2>
<div class="outline-text-2" id="text-9">
<blockquote>
<p>
Try to predict the values of the following expressions:
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-haskell">map fst [(1,2), (3,8), (0,6), (3,1)]

(foldr f 0 l, foldl f 0 l)
  where l = [6,9,8,3,10]
	f x y = (x+y) `div` 2

foldr (++) [] [[1,2,3], [4,5,6], [], [7]]
</pre>
</div>

<p>
a)
</p>

<p>
Recall the definition of:
</p>
<div class="org-src-container">

<pre class="src src-haskell">fst :: (a,b) -&gt; a
fst (x,_) = x

map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map _ []     = []
map f (x:xs) = f x : map f xs

-- or using list comprehension:
map f xs = [ f x | x &lt;- xs]
</pre>
</div>

<p>
We can then conclude:
</p>
<div class="org-src-container">

<pre class="src src-haskell">map fst [(1,2), (3,8), (0,6), (3,1)] = [1,3,0,3]
</pre>
</div>

<p>
b)
Again recall the definition of foldr:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr _ x []     = x
foldr f x (y:ys) = f y $ foldr f x ys
</pre>
</div>

<p>
Thus:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foldr f 0 l = foldr f 0 [6,9,8,3,10]
	    = f 6 (foldr f 0 [9,8,3,10])
	    = f 6 (f 9 (foldr f 0 [8,3,10]))
	    = ...
	    = f 6 (f 9 (f 8 (f 3 (f 10 0))))
	    = f 6 (f 9 (f 8 (f 3 (10+0 `div` 2))))
	    = f 6 (f 9 (f 8 (f 3 5)))
	    = f 6 (f 9 (f 8 (3 + 4 `div` 2)))
	    = f 6 (f 9 (f 8 3))
	    = f 6 (f 9 5)
	    = f 6 7
	    = 6
</pre>
</div>

<p>
Now the right operand, using foldl as operations:
</p>
<div class="org-src-container">

<pre class="src src-haskell">foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
foldl _ x []     = x
foldl f x (y:ys) = foldl f (f x y) ys
</pre>
</div>

<p>
Thus (I do not forget that haskell is lazy, just bear with me)
</p>
<div class="org-src-container">

<pre class="src src-haskell">foldl f 0 l = foldl f 0        [6,9,8,3,10]
	    = foldl f (f 0 6)  [9,8,3,10]
	    = foldl f (f 1 9)  [8,3,10]
	    = foldl f (f 5 8)  [3,10]
	    = foldl f (f 6 3)  [10]
	    = foldl f (f 5 10) []
	    = foldl f 7        []
	    = 7
</pre>
</div>

<p>
to conclude:
</p>
<div class="org-src-container">

<pre class="src src-haskell">(foldr f 0 l, foldl f 0 l)
  where l = [6,9,8,3,10]
	f x y = (x+y) `div` 2 -- (6,7)
</pre>
</div>

<p>
Indeed:
</p>
<div class="org-src-container">

<pre class="src src-haskell">tmp :: (Integer, Integer)
tmp = (foldr f 0 l, foldl f 0 l)
  where l = [6,9,8,3,10]
	f x y = (x+y) `div` 2

*Ch1&gt; tmp
(6,7)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">type</h2>
<div class="outline-text-2" id="text-10">
<blockquote>
<p>
What is the type of the following function?
<code>compose f g x = f (g x)</code>
</p>
</blockquote>

<p>
As we can see from the definition of compose:
</p>
<ul class="org-ul">
<li>f and g takes one parameter each.
</li>
<li>f takes the output type of g as input.
</li>
</ul>

<p>
We can sum up the definition of g and f:
</p>
<div class="org-src-container">

<pre class="src src-haskell">g :: a -&gt; b
f :: b -&gt; c
</pre>
</div>

<p>
Thus:
</p>
<div class="org-src-container">

<pre class="src src-haskell">compose :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</pre>
</div>

<p>
Check:
</p>

<div class="org-src-container">

<pre class="src src-haskell">compose :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
compose f g x = f (g x)
</pre>
</div>

<p>
Using <code>compose</code>, we could redefine the <code>string2int</code> function from earlier:
</p>
<div class="org-src-container">

<pre class="src src-haskell">string2int' :: String -&gt; Int
string2int' xs = sum [ compose (* u) digitToInt x | (u, x) &lt;- zip unit (reverse xs)]
		 where unit = iterate (* 10) 1
</pre>
</div>

<p>
The standard composition function is (.)
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch1&gt; :t (.)
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">matrix</h2>
<div class="outline-text-2" id="text-11">
<blockquote>
<p>
Given the matrix:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">2 3 4</td>
</tr>

<tr>
<td class="left">5 6 7</td>
</tr>

<tr>
<td class="left">8 9 10</td>
</tr>
</tbody>
</table>
<p>
a) Define a function that transposes a square matrix of size 3.
If applied to the previous matrix, the result should be:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">2 5 8</td>
</tr>

<tr>
<td class="left">3 6 9</td>
</tr>

<tr>
<td class="left">4 7 10</td>
</tr>
</tbody>
</table>
<p>
b) Extends this definition for a matrix of any size
</p>
</blockquote>

<p>
a)
</p>
<div class="org-src-container">

<pre class="src src-haskell">transpose3 :: [[a]] -&gt; [[a]]
transpose3 xs = map (\ n -&gt; map (!! n) xs) [0..2]

*Ch1&gt; transpose3 [[1,2,3], [4,5,6], [7,8,9]]
[[1,4,7],[2,5,8],[3,6,9]]
</pre>
</div>

<p>
b)
</p>
<div class="org-src-container">

<pre class="src src-haskell">transpose :: [[a]] -&gt; [[a]]
transpose xs = map (\ n -&gt; map (!! n) xs) [0..l]
	       where l = length xs - 1

*Ch1&gt; transpose [[1,2,3], [4,5,6], [7,8,9]]
[[1,4,7],[2,5,8],[3,6,9]]
*Ch1&gt; transpose [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]]
[[1,5,9,13],[2,6,10,14],[3,7,11,15],[4,8,12,16]]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">type</h2>
<div class="outline-text-2" id="text-12">
<p>
Determine the type definitions (with the context) of the following functions:
</p>
<div class="org-src-container">

<pre class="src src-haskell">cube x = x * x * x

maxi x y | x &gt;= y = x
	 | otherwise = y

sumAtoB a b = sum [a..b]
</pre>
</div>

<p>
We must be able to compute the multiplication on x, so this must be of type Num.
</p>
<div class="org-src-container">

<pre class="src src-haskell">cube :: Num a =&gt; a -&gt; a
cube x = x * x * x
</pre>
</div>

<p>
We must be able to compare the number, so type Ord.
</p>
<div class="org-src-container">

<pre class="src src-haskell">maxi :: (Ord a) =&gt; a -&gt; a -&gt; a
maxi x y | x &gt;= y = x
	 | otherwise = y
</pre>
</div>

<p>
We must be able to compute the sum, so Num type and use a list comprehension, so Enum type.
</p>
<div class="org-src-container">

<pre class="src src-haskell">sumAtoB :: (Num a, Enum a) =&gt; a -&gt; a -&gt; a
sumAtoB a b = sum [a..b]
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: <span class="timestamp-wrapper"><span class="timestamp">[2013-06-01 sam. 17:11]</span></span></p>
<p class="author">Author: Antoine R. Dumont</p>
<p class="date">Created: 2014-12-02 Tue 18:41</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

<p>
Here is the last part of the chapter 10's exercises.
Previous part:
</p>
<ul class="org-ul">
<li><a href="http://adumont.fr/blog/?p=1050">First</a>
</li>
<li><a href="http://adumont.fr/blog/?p=1064">Second</a>
</li>
</ul>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Abstract Machine</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
Extend the abstract machine to support the use of multiplication.
</p>
</blockquote>

<p>
The code adapted to deal with multiplication:
</p>
<div class="org-src-container">

<pre class="src src-haskell">data Expr = Val Int | Add Expr Expr | Mult Expr Expr deriving Show

data Op = EVALM Expr | EVALA Expr | MUL Int | ADD Int deriving Show

type Cont = [Op]

eval :: Expr -&gt; Cont -&gt; Int
eval (Val n)    c = exec c n
eval (Mult x y) c = eval x (EVALM y : c)
eval (Add x y)  c = eval x (EVALA y : c)

exec :: Cont -&gt; Int -&gt; Int
exec []            n = n
exec (EVALM y : c) n = eval y (MUL n : c)
exec (EVALA y : c) n = eval y (ADD n : c)
exec (MUL m : c)   n = exec c (n * m)
exec (ADD m : c)   n = exec c (n + m)

val :: Expr -&gt; Int
val e = eval e []
</pre>
</div>

<p>
Output:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*AbstractMachine&gt; val (Mult (Val 10) (Val 5))
50
*AbstractMachine&gt; val (Add (Mult (Val 10) (Val 5)) (Val 100))
150
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Instance</h2>
<div class="outline-text-2" id="text-2">
<blockquote>
<p>
Complete the following instance declarations:
=
instance Monad Maybe where
···
instance Monad [] where
···
=
In this context, [] denotes the list type [a] without its parameter.
</p>

<p>
<span class="underline">Hint:</span> First write down the types of <code>return</code> and <code>&gt;&gt;=</code> for each instance.
</p>
</blockquote>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">May(be)</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">data</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
The data May(be) definition:
</p>
<div class="org-src-container">

<pre class="src src-haskell">data May a = Noth | Jus a
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">inject</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
To inject a value into the Maybe world, we wrap this value into a Jus and we're done:
</p>

<div class="org-src-container">

<pre class="src src-haskell">return = Jus
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3">bind</h4>
<div class="outline-text-4" id="text-2-1-3">
<ul class="org-ul">
<li>Noth binds to anything is Noth.
</li>
<li>And if it is a value (Jus x)m then we can bind it to the monadic function f (f x).
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell">Noth  &gt;&gt;= _ = Noth
(Jus x) &gt;&gt;= f = f x
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4">complete</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
Complete definition:
</p>
<div class="org-src-container">

<pre class="src src-haskell">data May a = Noth | Jus a

instance Monad May where
	 return = Jus

	 Noth  &gt;&gt;= _ = Noth
	 (Jus x) &gt;&gt;= f = f x
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">[]</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1">inject</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
To inject a value in the monadic world of list, just create a singleton list with this value:
</p>
<div class="org-src-container">

<pre class="src src-haskell">-- return :: a -&gt; [a]
return x = [x]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2">bind</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
To bind a list to the monadic function f, apply the monadic function f to the content of the list (so concatMap):
</p>

<div class="org-src-container">

<pre class="src src-haskell">-- [a] -&gt; (a -&gt; [b]) -&gt; [b]
l &gt;&gt;= f = concatMap f l
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3">complete</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-haskell">instance Monad [] where
	 return v = [v]

	 -- m a -&gt; (a -&gt; m b) -&gt; m b
	 -- [a] -&gt; (a -&gt; [b]) -&gt; [b]
	 l &gt;&gt;= f = concatMap f l
</pre>
</div>
</div>
</div>
</div>
</div>

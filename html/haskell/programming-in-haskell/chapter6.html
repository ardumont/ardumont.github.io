<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>PIH - ch6 - Recursive functions</title>
<!-- 2014-12-01 Mon 23:46 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Antoine R. Dumont" />
<meta  name="description" content="recursion exercises in Haskell"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="../other/style.css" type="text/css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">PIH - ch6 - Recursive functions</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Exponentiation</a></li>
<li><a href="#sec-2">evaluated</a>
<ul>
<li><a href="#sec-2-1">length</a></li>
<li><a href="#sec-2-2">drop</a></li>
<li><a href="#sec-2-3">init</a></li>
</ul>
</li>
<li><a href="#sec-3">functions</a>
<ul>
<li><a href="#sec-3-1"><b>and</b></a></li>
<li><a href="#sec-3-2"><b>concat</b></a></li>
<li><a href="#sec-3-3"><b>replicate</b></a></li>
<li><a href="#sec-3-4"><b>(!!)</b></a></li>
<li><a href="#sec-3-5"><b>elem</b></a></li>
</ul>
</li>
<li><a href="#sec-4">merge</a></li>
<li><a href="#sec-5">msort</a></li>
<li><a href="#sec-6">sum</a>
<ul>
<li><a href="#sec-6-1"><b>sum</b></a></li>
<li><a href="#sec-6-2"><b>take</b></a></li>
<li><a href="#sec-6-3"><b>last</b></a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
In this chapter were introduced the <a href="http://en.wikipedia.org/wiki/Recursion">recursion</a>, basic mechanism to loop in <a href="https://www.google.fr/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&ved=0CDIQFjAA&url=http://www.haskell.org/&ei=aT_oUND0D822hAeP9YCoBQ&usg=AFQjCNEUgp4cz-Ux4IBG1O3XhObfY7iizg&sig2=amLa4mWW73L7I3YzXRDNHw&bvm=bv.1355534169,d.ZG4">Haskell</a>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Exponentiation</h2>
<div class="outline-text-2" id="text-1">
<blockquote>
<p>
Define the exponentiation operator ↑ for non-negative integers using the
same pattern of recursion as the multiplication operator <code>∗</code>, and show how <b>2 ↑ 3</b> is evaluated using your definition.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">(^) :: Int -&gt; Int -&gt; Int
_ ^ 0 = 1
x ^ n = x * (x ^ (n-1))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-text">2 ^ 3 = 2 * (2 ^ 2)
      = 2 * 2 * (2 ^ 1)
      = 2 * 2 * 2 * (2 ^ 0)
      = 2 * 2 * 2 * 1
      = 8
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">evaluated</h2>
<div class="outline-text-2" id="text-2">
<blockquote>
<p>
Using the definitions given in this chapter, show how <b>length [1, 2, 3]</b>,
<b>drop 3 [1, 2, 3, 4, 5]</b>, and <b>init [1, 2, 3]</b> are evaluated.
</p>
</blockquote>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">length</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Given the definition:
</p>
<div class="org-src-container">

<pre class="src src-haskell">length :: [a] -&gt; Int
length [] = 0
length (_:xs) = 1 + length xs
</pre>
</div>

<div class="org-src-container">

<pre class="src src-text">length [1,2,3] = 1 + length [2,3]
	       = 1 + 1 + length [3]
	       = 1 + 1 + 1 + length []
	       = 1 + 1 + 1 + 0
	       = 3
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">drop</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Given the definition:
</p>
<div class="org-src-container">

<pre class="src src-haskell">drop :: Int -&gt; [a] -&gt; [a]
drop 0 ys = ys
drop _ [] = []
drop n (_:ys) = drop (n-1) ys
</pre>
</div>

<div class="org-src-container">

<pre class="src src-text">drop 3 [1,2,3,4,5] = drop 2 [2,3,4,5]
		   = drop 1 [3,4,5]
		   = drop 0 [4,5]
		   = [4,5]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">init</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Given the definition:
</p>
<div class="org-src-container">

<pre class="src src-haskell">init :: [a] -&gt; [a]
init [_] = []
init (x:xs) = x:(init xs)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-text">init [1,2,3] = 1:(init [2,3])
	     = 1:2:(init [3])
	     = 1:2:[]
	     = [1,2]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">functions</h2>
<div class="outline-text-2" id="text-3">
<blockquote>
<p>
Without looking at the definitions from the standard prelude, define the
following library functions using recursion:
&#x2013; and
&#x2013; concat
&#x2013; replicate
&#x2013; (!!)
&#x2013; elem
</p>

<p>
<b>Note:</b> most of these functions are in fact defined in the prelude using other
library functions, rather than using explicit recursion.
</p>
</blockquote>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><b>and</b></h3>
<div class="outline-text-3" id="text-3-1">
<blockquote>
<p>
&#x2013; Decide if all logical values in a list are True: <code>and :: [Bool] → Bool</code>
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">and :: [Bool] -&gt; Bool
and [] = True
and (x:xs) = x &amp;&amp; (and xs)
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; and [True, True, True]
True
*Ch6&gt; and [True, False, True]
False
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><b>concat</b></h3>
<div class="outline-text-3" id="text-3-2">
<blockquote>
<p>
&#x2013; Concatenate a list of lists: <code>concat :: [[a] ] → [a]</code>
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">concat :: [[a]] -&gt; [a]
concat [xs] = xs
concat (xs:xxs) = xs ++ (concat xxs)
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; concat [[1..10], [2,4], [20..25]]
[1,2,3,4,5,6,7,8,9,10,2,4,20,21,22,23,24,25]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><b>replicate</b></h3>
<div class="outline-text-3" id="text-3-3">
<blockquote>
<p>
&#x2013; Produce a list with n identical elements: <code>replicate :: Int → a → [a]</code> <br  />
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">replicate :: Int -&gt; a -&gt; [a]
replicate 0 _ = []
replicate n x = x:(replicate (n-1) x)
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; replicate 10 'a'
"aaaaaaaaaa"
*Ch6&gt; replicate 5 9
[9,9,9,9,9]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><b>(!!)</b></h3>
<div class="outline-text-3" id="text-3-4">
<blockquote>
<p>
&#x2013; Select the n<sup>th</sup> element of a list: <code>(!!) :: [a] → Int → a</code> <br  />
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">(!!) :: [a] -&gt; Int -&gt; a
(x:_) !! 0 = x
(_:xs) !! n = xs !! (n-1)
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; [1,2,3] !! 2
3
*Ch6&gt; [1,2,3] !! 0
1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><b>elem</b></h3>
<div class="outline-text-3" id="text-3-5">
<blockquote>
<p>
&#x2013; Decide if a value is an element of a list: <code>elem :: Eq a ⇒ a → [a] → Bool</code> <br  />
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">elem :: Eq a =&gt; a -&gt; [a] -&gt; Bool
elem _ [] = False
elem x (y:ys) | x == y    = True
	      | otherwise = elem x ys
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; elem 1 [10,20,30]
False
*Ch6&gt; elem 10 [10,20,30]
True
*Ch6&gt; elem 40 [10,20,30,40]
True
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">merge</h2>
<div class="outline-text-2" id="text-4">
<blockquote>
<p>
Define a recursive function <code>merge :: Ord a ⇒ [a] → [a] → [a]</code> that
merges two sorted lists to give a single sorted list.
</p>

<p>
For example:
</p>

<p>
&gt; merge [2, 5, 6] [1, 3, 4]
[1, 2, 3, 4, 5, 6]
</p>

<p>
<b>Note:</b> your definition should not use other functions on sorted lists such as
<b>insert</b> or <b>isort</b>, but should be defined using explicit recursion.
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-haskell">merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys) | x &lt;= y    = x : merge xs     (y:ys)
		    | otherwise = y : merge (x:xs) ys
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; merge [2,5,6] [1,3,4]
[1,2,3,4,5,6]
*Ch6&gt; merge [10..20] [1..10]
[1,2,3,4,5,6,7,8,9,10,10,11,12,13,14,15,16,17,18,19,20]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">msort</h2>
<div class="outline-text-2" id="text-5">
<blockquote>
<p>
Using <b>merge</b>, define a recursive function <code>msort :: Ord a ⇒ [a] → [a]</code> that
implements merge sort, in which the empty list and singleton lists are already
sorted, and any other list is sorted by merging together the two lists that
result from sorting the two halves of the list separately.
</p>

<p>
<b>Hint:</b>
First define a function <code>halve :: [a] → ([a], [a])</code> that splits a list into
two halves whose lengths differ by at most one.
</p>
</blockquote>

<p>
First, following the hint, we define a <b>halve</b> function:
</p>
<div class="org-src-container">

<pre class="src src-haskell">halve :: [a] -&gt; ([a], [a])
halve xs = splitAt (length xs `div` 2) xs
</pre>
</div>

<p>
As an example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; halve [1,2,3]
([1],[2,3])
*Ch6&gt; fst ([1],[2,3])
[1]
*Ch6&gt; snd ([1],[2,3])
[2,3]
</pre>
</div>

<p>
Now:
</p>
<div class="org-src-container">

<pre class="src src-haskell">msort :: Ord a =&gt; [a] -&gt; [a]
msort [] = []
msort [x] = [x]
msort xs = merge (msort fh) (msort sh)
	   where
	     (fh, sh) = halve xs
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; msort [3,2,90,54,1]
[1,2,3,54,90]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">sum</h2>
<div class="outline-text-2" id="text-6">
<blockquote>
<p>
Using the five-step process, define the library functions that calculate the
<b>sum</b> of a list of numbers, <b>take</b> a given number of elements from the start of
a list, and select the <b>last</b> element of a non-empty list.
</p>
</blockquote>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><b>sum</b></h3>
<div class="outline-text-3" id="text-6-1">
<blockquote>
<p>
Calculate the <b>sum</b> of a list of numbers.
</p>
</blockquote>
</div>

<div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1">Step 1 - define the types</h4>
<div class="outline-text-4" id="text-6-1-1">
<div class="org-src-container">

<pre class="src src-haskell">sum :: Num a =&gt; [a] -&gt; a
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-1-2" class="outline-4">
<h4 id="sec-6-1-2">Step 2 - enumerate the cases</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
Then what are the cases:
</p>
<div class="org-src-container">

<pre class="src src-haskell">sum []
sum (x:xs)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-1-3" class="outline-4">
<h4 id="sec-6-1-3">Step 3 - Define the simple case</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
Then defining it:
</p>
<div class="org-src-container">

<pre class="src src-haskell">sum [] = 0
</pre>
</div>

<p>
0 is the identity of the sum.
</p>
</div>
</div>
<div id="outline-container-sec-6-1-4" class="outline-4">
<h4 id="sec-6-1-4">Step 4 - Define the other cases</h4>
<div class="outline-text-4" id="text-6-1-4">
<div class="org-src-container">

<pre class="src src-haskell">sum (x:xs) = x + sum xs
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-1-5" class="outline-4">
<h4 id="sec-6-1-5">Step 5 - Generalise and simplify</h4>
<div class="outline-text-4" id="text-6-1-5">
<p>
First, what do we got?
</p>

<div class="org-src-container">

<pre class="src src-haskell">sum :: Num a =&gt; [a] -&gt; a
sum [] = 0
sum (x:xs) = x + sum xs
</pre>
</div>

<p>
This follows the same recursion pattern that the one for <b>product</b>, which is encapsulated in the <b>foldr</b> function, thus simplifying gives:
</p>
<div class="org-src-container">

<pre class="src src-haskell">sum :: Num a =&gt; [a] -&gt; a
sum = foldr (+) 0
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; summ [3,2,90,54,1]
150
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><b>take</b></h3>
<div class="outline-text-3" id="text-6-2">
<blockquote>
<p>
<b>take</b> a given number of elements.
</p>
</blockquote>
</div>


<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1">Step 1 - define the types</h4>
<div class="outline-text-4" id="text-6-2-1">
<div class="org-src-container">

<pre class="src src-haskell">take :: Int -&gt; [a] -&gt; [a]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2">Step 2 - enumerate the cases</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
Then what are the cases:
</p>
<ul class="org-ul">
<li>we take no elements in any list
</li>
<li>or we take some elements in an empty list.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-haskell">take 0 _ =
take _ [] =
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-2-3" class="outline-4">
<h4 id="sec-6-2-3">Step 3 - Define the simple case</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
Either way, we return an empty list.
</p>
<div class="org-src-container">

<pre class="src src-haskell">take 0 _ = []
take _ [] = []
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-2-4" class="outline-4">
<h4 id="sec-6-2-4">Step 4 - Define the other cases</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
We take the head of the list, it becomes the head of a new list.
The tail of the list is made by taking <b>n-1</b> elements in <b>xs</b>.
</p>
<div class="org-src-container">

<pre class="src src-haskell">take n (x:xs) = x : (take (n-1) xs)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-2-5" class="outline-4">
<h4 id="sec-6-2-5">Step 5 - Generalise and simplify</h4>
<div class="outline-text-4" id="text-6-2-5">
<p>
First, what do we got?
</p>

<div class="org-src-container">

<pre class="src src-haskell">take :: Int -&gt; [a] -&gt; [a]
take 0 _ = []
take _ [] = []
take n (x:xs) = x : (take (n-1) xs)
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; take 0 [1..10]
[]
*Ch6&gt; take 10 []
[]
*Ch6&gt; take 3 [1..10]
[1,2,3]
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><b>last</b></h3>
<div class="outline-text-3" id="text-6-3">
<blockquote>
<p>
Select the <b>last</b> element of a non empty list.
</p>
</blockquote>
</div>

<div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1">Step 1 - define the types</h4>
<div class="outline-text-4" id="text-6-3-1">
<div class="org-src-container">

<pre class="src src-haskell">last :: [a] -&gt; a
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-3-2" class="outline-4">
<h4 id="sec-6-3-2">Step 2 - enumerate the cases</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
Then what are the cases:
</p>
<div class="org-src-container">

<pre class="src src-haskell">last []
last [x]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-3-3" class="outline-4">
<h4 id="sec-6-3-3">Step 3 - Define the simple case</h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
Then defining it:
</p>
<div class="org-src-container">

<pre class="src src-haskell">last [] = []
last [x] = x
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-3-4" class="outline-4">
<h4 id="sec-6-3-4">Step 4 - Define the other cases</h4>
<div class="outline-text-4" id="text-6-3-4">
<div class="org-src-container">

<pre class="src src-haskell">last (_:xs) = last xs
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-3-5" class="outline-4">
<h4 id="sec-6-3-5">Step 5 - Generalise and simplify</h4>
<div class="outline-text-4" id="text-6-3-5">
<p>
First, what do we got?
</p>

<div class="org-src-container">

<pre class="src src-haskell">last :: [a] -&gt; a
last [x] = x
last (x:xs) = last xs
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-haskell">*Ch6&gt; last [1..10]
10
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: <span class="timestamp-wrapper"><span class="timestamp">[2013-01-02 mer. 20:16]</span></span></p>
<p class="author">Author: Antoine R. Dumont</p>
<p class="date">Created: 2014-12-01 Mon 23:46</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

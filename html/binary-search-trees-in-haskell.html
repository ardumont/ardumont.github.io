<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Binary Search Trees</title>
<!-- 2014-12-01 Mon 23:46 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Antoine R. Dumont" />
<meta  name="description" content="Having fun implementing some binary search trees functions"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="../other/style.css" type="text/css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Binary Search Trees</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Binary Search Tree</a>
<ul>
<li><a href="#sec-1-1">Type</a></li>
<li><a href="#sec-1-2">Utility</a></li>
<li><a href="#sec-1-3">Sample trees</a></li>
<li><a href="#sec-1-4">Size</a></li>
<li><a href="#sec-1-5">toList</a></li>
<li><a href="#sec-1-6">Sorted List</a></li>
<li><a href="#sec-1-7">Smallest value</a></li>
<li><a href="#sec-1-8">Greatest values</a></li>
<li><a href="#sec-1-9">Mirror</a></li>
<li><a href="#sec-1-10">Contains</a></li>
<li><a href="#sec-1-11">Right son</a></li>
<li><a href="#sec-1-12">Left son</a></li>
<li><a href="#sec-1-13">Insert</a></li>
<li><a href="#sec-1-14">isBSearchTree</a></li>
<li><a href="#sec-1-15">deleteMax</a></li>
<li><a href="#sec-1-16">deleteMin</a></li>
<li><a href="#sec-1-17">Remove</a></li>
</ul>
</li>
<li><a href="#sec-2">Sources</a></li>
</ul>
</div>
</div>
<blockquote>
<p>
Given the following binary Tree data type <code>data (Ord a) =&gt; Tree a = Empty | Node a (Tree a) (Tree a)</code>, provide an implementation of all functions defined in this file.
</p>

<p>
To enforce the property of Binary Search Trees, functions that insert elements in the given Tree must be implemented in such a way that the invariant of a binary search tree always hold.
</p>
</blockquote>

<p>
<span class="underline">Note</span> To avoid repetition, we will add directly some haskell sample computed in the repl and add them directly after the function definition.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Binary Search Tree</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Type</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A tree is either an emtpy node or a node composed of a left tree and a right tree.
</p>

<div class="org-src-container">

<pre class="src src-haskell">data (Ord a) =&gt; Tree a = Empty | Node a (Tree a) (Tree a)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Utility</h3>
<div class="outline-text-3" id="text-1-2">
<p>
A utility function to create easily a leaf.
</p>

<div class="org-src-container">

<pre class="src src-haskell">leaf :: a -&gt; Tree a
leaf x = Node x Empty Empty
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Sample trees</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Here are the 2 trees we will use to check the functions:
</p>

<div class="org-src-container">

<pre class="src src-haskell">t1 :: Tree Int
t1 = Node 4 (leaf 3) (Node 7 (leaf 5) (leaf 10))

t2 :: Tree Int
t2 = Node 20 (Node 15 (Node 8 (leaf 7) (leaf 11)) (leaf 18))
	     (Node 118
		     (Node 35 (leaf 33) (Node 49 Empty (leaf 60)))
		     (leaf 166))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Size</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The size of the tree is taken to be the number n of internal nodes
</p>
<div class="org-src-container">

<pre class="src src-haskell">those with two children)
size :: Num a =&gt; Tree b -&gt; a
size Empty        = 0
size (Node _ l r) = 1 + size l + size r

*BinarySearchTree&gt; size t1
5
*BinarySearchTree&gt; size t2
12
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">toList</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Returns an unsorted list of all values in the given Tree
A supplementary constraint is that we need to be able to rebuild the tree from the list.
</p>

<div class="org-src-container">

<pre class="src src-haskell">toList :: Tree a -&gt; [a]
toList Empty        = []
toList (Node x l r) = [x] ++ (toList l) ++ (toList r)

*BinarySearchTree&gt; toList t1
[4,3,7,5,10]
*BinarySearchTree&gt; toList t2
[20,15,8,7,11,18,118,35,33,49,60,166]
</pre>
</div>

<p>
To check that we can rebuild the tree from the previous output, we will create a function fromList that creates a Tree from a list:
</p>
<div class="org-src-container">

<pre class="src src-haskell">fromList :: Ord a =&gt; [a] -&gt; Tree a
fromList []     = Empty
fromList (x:xs) = Node x (fromList lefts) (fromList rights)
		  where p      = (&lt;= x)
			lefts  = takeWhile p xs
			rights = dropWhile p xs
</pre>
</div>

<p>
We can now check that we can rebuild the tree from the list computed from the toList function.
</p>
<div class="org-src-container">

<pre class="src src-haskell">*BinarySearchTree&gt; (fromList . toList) t1 == t1
True
*BinarySearchTree&gt; (fromList . toList) t1 == (leaf 1)
False
*BinarySearchTree&gt; (fromList . toList) t2 == t2
True
*BinarySearchTree&gt; (fromList . toList) t2 == (leaf 1)
False
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Sorted List</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Returns a sorted list of all elements of the given Tree.
</p>

<div class="org-src-container">

<pre class="src src-haskell">toSortedList :: Tree a -&gt; [a]
toSortedList Empty        = []
toSortedList (Node x l r) = toSortedList l ++ [x] ++ toSortedList r

*BinarySearchTree&gt; toSortedList t1
[3,4,5,7,10]
*BinarySearchTree&gt; toSortedList t2
[7,8,11,15,18,20,33,35,49,60,118,166]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Smallest value</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Returns the smallest value in the given Tree.
Given the nature of the tree, as long as the tree has left branches, we continue the computation from the left branch.
When no left branch remains, we have the smallest value.
</p>

<div class="org-src-container">

<pre class="src src-haskell">smallValue :: Tree a -&gt;  Maybe a
smallValue Empty            = Nothing
smallValue (Node x Empty _) = Just x
smallValue (Node _ l _)     = smallValue l

*BinarySearchTree&gt; smallValue t1 == Just (head (toSortedList t1))
True
*BinarySearchTree&gt; smallValue t2 == Just (head (toSortedList t2))
True
*BinarySearchTree&gt; smallValue Empty == Nothing
True
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">Greatest values</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Returns the greatest value in the given Tree.
Symmetrically, we continue the computation from the right branch.
When no right branch remains, we have the greatest value.
</p>

<div class="org-src-container">

<pre class="src src-haskell">Returns the greatest value in the the given Tree
greatValue :: Tree a -&gt; Maybe a
greatValue Empty            = Nothing
greatValue (Node x _ Empty) = Just x
greatValue (Node _ _ r)     = greatValue r

*BinarySearchTree&gt; greatValue t1 == Just (last (toSortedList t1))
True
*BinarySearchTree&gt; greatValue t2 == Just (last (toSortedList t2))
True
*BinarySearchTree&gt; greatValue Empty == Nothing
True
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">Mirror</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Returns the mirror of the given Tree.
The mirror tree is a tree where all left and right branches are permuted and this recursively.
</p>

<div class="org-src-container">

<pre class="src src-haskell">mirror :: Tree a -&gt; Tree a
mirror Empty        = Empty
mirror (Node x l r) = Node x (mirror r) (mirror l)

*BinarySearchTree&gt; t1
Node 4 (Node 3 Empty Empty) (Node 7 (Node 5 Empty Empty) (Node 10 Empty Empty))
*BinarySearchTree&gt; mirror t1
Node 4 (Node 7 (Node 10 Empty Empty) (Node 5 Empty Empty)) (Node 3 Empty Empty)
*BinarySearchTree&gt; t2
Node 20 (Node 15 (Node 8 (Node 7 Empty Empty) (Node 11 Empty Empty)) (Node 18 Empty Empty)) (Node 118 (Node 35 (Node 33 Empty Empty) (Node 49 Empty (Node 60 Empty Empty))) (Node 166 Empty Empty))
*BinarySearchTree&gt; mirror t2
Node 20 (Node 118 (Node 166 Empty Empty) (Node 35 (Node 49 (Node 60 Empty Empty) Empty) (Node 33 Empty Empty))) (Node 15 (Node 18 Empty Empty) (Node 8 (Node 11 Empty Empty) (Node 7 Empty Empty)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">Contains</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Returns whether the given Tree contains the given element or not.
</p>

<div class="org-src-container">

<pre class="src src-haskell">contains :: Ord a =&gt; Tree a -&gt; a -&gt; Bool
contains Empty _        = False
contains (Node x l r) y = case compare y x of
  EQ -&gt; True
  LT -&gt; contains l y
  GT -&gt; contains r y

*BinarySearchTree&gt; contains t1 3
True
*BinarySearchTree&gt; contains t1 4
True
*BinarySearchTree&gt; contains t1 7
True
*BinarySearchTree&gt; contains t1 5
True
*BinarySearchTree&gt; contains t1 10
True
*BinarySearchTree&gt; contains t1 11
False
*BinarySearchTree&gt; contains t1 1
False
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">Right son</h3>
<div class="outline-text-3" id="text-1-11">
<p>
Returns the right son of the given Tree.
</p>

<div class="org-src-container">

<pre class="src src-haskell">rightSon :: Tree a -&gt; Tree a
rightSon Empty        = Empty
rightSon (Node _ _ r) = r

*BinarySearchTree&gt; t1
Node 4 (Leaf 3) (Node 7 (Leaf 5) (Leaf 10))
*BinarySearchTree&gt; rightSon t1
Node 7 (Leaf 5) (Leaf 10)
*BinarySearchTree&gt; t2
Node 20 (Node 15 (Node 8 (Leaf 7) (Leaf 11)) (Leaf 18)) (Node 118 (Node 35 (Leaf 33) (Node 49 (Leaf 48) (Leaf 60))) (Leaf 166))
*BinarySearchTree&gt; rightSon t2
Node 118 (Node 35 (Leaf 33) (Node 49 (Leaf 48) (Leaf 60))) (Leaf 166)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">Left son</h3>
<div class="outline-text-3" id="text-1-12">
<p>
Returns the left son of the given Tree.
</p>

<div class="org-src-container">

<pre class="src src-haskell">leftSon :: Tree a -&gt; Tree a
leftSon Empty        = Empty
leftSon (Node _ l _) = l
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">Insert</h3>
<div class="outline-text-3" id="text-1-13">
<p>
Insert a new ordered value into the tree.
Note that it preserves the Binary Search Tree properties.
This insert implementation does not need to keep the balanced properties.
</p>


<div class="org-src-container">

<pre class="src src-haskell">insert :: (Ord a) =&gt; Tree a -&gt; a -&gt; Tree a
insert Empty x = leaf x
insert (Node x l r) y = case compare y x of
  GT -&gt; Node x l (insert r y)
  _  -&gt; Node x (insert l y) r

*BinarySearchTree&gt; insert t1 10
Node 4 (Leaf 3) (Node 7 (Leaf 5) (Node 10 (Leaf 10) Empty))
*BinarySearchTree&gt; insert t2 200
Node 20 (Node 15 (Node 8 (Leaf 7) (Leaf 11)) (Leaf 18)) (Node 118 (Node 35 (Leaf 33) (Node 49 (Leaf 48) (Leaf 60))) (Node 200 (Leaf 166) Empty))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14">isBSearchTree</h3>
<div class="outline-text-3" id="text-1-14">
<p>
Is this tree a binary search one?
</p>

<p>
For this, I created a utility function to retrieve the value of a node.
</p>

<div class="org-src-container">

<pre class="src src-haskell">value :: Tree a -&gt; Maybe a
value Empty        = Nothing
value (Node x _ _) = Just x

*BinarySearchTree&gt; value (Node 10 Empty Empty)
Just 10
*BinarySearchTree&gt; value (Leaf 10)
Just 10
*BinarySearchTree&gt; value Empty
Nothing

isBSearchTree :: (Ord a) =&gt; Tree a -&gt; Bool
isBSearchTree Empty = True
isBSearchTree (Node x l r) =
  case [value l, value r] of
    [Nothing, Nothing] -&gt; True
    [Nothing, Just z]  -&gt; and [x &lt; z, isBSearchTree l, isBSearchTree r]
    [Just y, Nothing]  -&gt; and [y &lt;= x, isBSearchTree l, isBSearchTree r]
    [Just y, Just z]   -&gt; and [y &lt;= x, x &lt; z, isBSearchTree l, isBSearchTree r]

*BinarySearchTree&gt; isBSearchTree (Node 10 t2 t1)
False
*BinarySearchTree&gt; isBSearchTree t1
True
*BinarySearchTree&gt; isBSearchTree t2
True
*BinarySearchTree&gt; isBSearchTree (insert t2 1)
True
*BinarySearchTree&gt; isBSearchTree (insert (insert t2 1) 100)
True
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15">deleteMax</h3>
<div class="outline-text-3" id="text-1-15">
<p>
Delete the maximal value from a tree.
</p>

<div class="org-src-container">

<pre class="src src-haskell">deleteMax :: Tree a -&gt; (Maybe a, Tree a)
deleteMax Empty            = (Nothing, Empty)
deleteMax (Node x _ Empty) = (Just x, Empty)
deleteMax (Node x l r)     = let (y, t) = deleteMax r in
			     (y, (Node x l t))

*BinarySearchTree&gt; t1
Node 4 (Node 3 Empty Empty) (Node 7 (Node 5 Empty Empty) (Node 10 Empty Empty))
*BinarySearchTree&gt; deleteMax t1
(Just 10,Node 4 (Node 3 Empty Empty) (Node 7 (Node 5 Empty Empty) Empty))
*BinarySearchTree&gt; t2
Node 20 (Node 15 (Node 8 (Node 7 Empty Empty) (Node 11 Empty Empty)) (Node 18 Empty Empty)) (Node 118 (Node 35 (Node 33 Empty Empty) (Node 49 Empty (Node 60 Empty Empty))) (Node 166 Empty Empty))
*BinarySearchTree&gt; deleteMax t2
(Just 166,Node 20 (Node 15 (Node 8 (Node 7 Empty Empty) (Node 11 Empty Empty)) (Node 18 Empty Empty)) (Node 118 (Node 35 (Node 33 Empty Empty) (Node 49 Empty (Node 60 Empty Empty))) Empty))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-16" class="outline-3">
<h3 id="sec-1-16">deleteMin</h3>
<div class="outline-text-3" id="text-1-16">
<p>
Delete the minimal value from a tree.
</p>

<div class="org-src-container">

<pre class="src src-haskell">deleteMin :: Tree a -&gt; (Maybe a, Tree a)
deleteMin Empty            = (Nothing, Empty)
deleteMin (Node x Empty _) = (Just x, Empty)
deleteMin (Node x l r)     = let (y, t) = deleteMin l in
			     (y, (Node x t r))

*BinarySearchTree&gt; t1
Node 4 (Node 3 Empty Empty) (Node 7 (Node 5 Empty Empty) (Node 10 Empty Empty))
*BinarySearchTree&gt; deleteMin t1
(Just 3,Node 4 Empty (Node 7 (Node 5 Empty Empty) (Node 10 Empty Empty)))
*BinarySearchTree&gt; t2
Node 20 (Node 15 (Node 8 (Node 7 Empty Empty) (Node 11 Empty Empty)) (Node 18 Empty Empty)) (Node 118 (Node 35 (Node 33 Empty Empty) (Node 49 Empty (Node 60 Empty Empty))) (Node 166 Empty Empty))
*BinarySearchTree&gt; deleteMin t2
(Just 7,Node 20 (Node 15 (Node 8 Empty (Node 11 Empty Empty)) (Node 18 Empty Empty)) (Node 118 (Node 35 (Node 33 Empty Empty) (Node 49 Empty (Node 60 Empty Empty))) (Node 166 Empty Empty)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-17" class="outline-3">
<h3 id="sec-1-17">Remove</h3>
<div class="outline-text-3" id="text-1-17">
<p>
Given a tree and an entry, remove the node from the tree.
This must only delete the node targeted and not all the branch from the node.
</p>

<div class="org-src-container">

<pre class="src src-haskell">remove :: Ord a =&gt; Tree a -&gt; a -&gt; Tree a
remove Empty _        = Empty
remove (Node x l r) y = case compare y x of
  LT -&gt; Node x (remove l y) r
  GT -&gt; Node x l (remove r y)
  EQ -&gt; case deleteMax l of
    (Just z, t) -&gt; Node z t r
    (Nothing, _) -&gt; case deleteMin r of
      (Just w, s) -&gt; Node w l s
      (Nothing, _) -&gt; Empty

*BinarySearchTree&gt; t1
Node 4 (Node 3 Empty Empty) (Node 7 (Node 5 Empty Empty) (Node 10 Empty Empty))
*BinarySearchTree&gt; remove t1 4
Node 3 Empty (Node 7 (Node 5 Empty Empty) (Node 10 Empty Empty))
*BinarySearchTree&gt; remove t1 10
Node 4 (Node 3 Empty Empty) (Node 7 (Node 5 Empty Empty) Empty)
*BinarySearchTree&gt; remove t1 7
Node 4 (Node 3 Empty Empty) (Node 5 Empty (Node 10 Empty Empty))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Sources</h2>
<div class="outline-text-2" id="text-2">
<p>
<a href="https://github.com/ardumont/my-haskell-lab/blob/master/src/BinarySearchTree.hs">BinarySearchTree.hs</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: <span class="timestamp-wrapper"><span class="timestamp">[2013-05-02 jeu. 20:43]</span></span></p>
<p class="author">Author: Antoine R. Dumont</p>
<p class="date">Created: 2014-12-01 Mon 23:46</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
